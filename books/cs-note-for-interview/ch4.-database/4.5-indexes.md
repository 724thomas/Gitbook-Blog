---
description: '인덱스: 데이터베이스 성능 최적화의 핵심'
---

# 4.5 Indexes

인덱스는 데이터베이스 성능을 최적화하는 중요한 도구입니다. 대량의 데이터에서 특정 레코드를 빠르게 검색하거나, 데이터를 효율적으로 정렬하기 위해 인덱스가 사용됩니다. 그러나 인덱스는 잘못 설계되거나 과도하게 사용될 경우 오히려 성능 저하를 일으킬 수 있습니다. 인덱스의 필요성과 다양한 인덱스 구조 및 최적화 기법을 이해하는 것이 중요합니다.

#### 4.5.1 인덱스의 필요성

**인덱스**는 데이터베이스에서 데이터를 빠르게 검색할 수 있도록 도와주는 자료 구조입니다. 데이터를 저장하는 테이블에서 특정 열(컬럼)에 대해 인덱스를 생성하면, 데이터베이스는 이 인덱스를 사용하여 검색 속도를 대폭 향상시킬 수 있습니다.

**예시**:\
사용자 테이블에서 이메일 주소로 특정 사용자를 검색한다고 가정해 봅시다. 만약 이메일 열에 인덱스가 없다면, 데이터베이스는 전체 테이블을 순차적으로 검색하여 해당 사용자를 찾아야 합니다. 이는 데이터가 많을수록 시간이 많이 소요됩니다. 그러나 이메일 열에 인덱스를 생성하면, 데이터베이스는 인덱스를 통해 해당 사용자의 위치를 신속하게 파악하여 검색 속도가 크게 향상됩니다.

```sql
CREATE INDEX idx_email ON users(email);
```

위 SQL 명령어는 `users` 테이블의 `email` 열에 인덱스를 생성하여 검색 속도를 높여줍니다.

#### 4.5.2 B-트리

\*\*B-트리(B-Tree)\*\*는 대부분의 관계형 데이터베이스 시스템에서 인덱스를 구현하는 데 사용되는 자료 구조입니다. B-트리는 균형 잡힌 트리 구조로, 데이터베이스는 이 구조를 통해 검색, 삽입, 삭제 작업을 효율적으로 처리할 수 있습니다. B-트리의 각 노드는 여러 개의 키와 자식을 가질 수 있으며, 트리의 깊이를 최소화하여 검색 작업의 효율성을 높입니다.

* **특징**: B-트리는 각 노드가 여러 자식을 가지며, 노드 간의 균형을 유지하는 구조로 되어 있습니다. 이는 데이터가 삽입되거나 삭제될 때도 트리가 균형 상태를 유지하도록 하여, 검색 및 삽입 작업이 항상 일정한 시간 내에 이루어지도록 보장합니다.
* **장점**: B-트리는 균형을 유지하여 모든 노드의 탐색 깊이가 동일하므로, 성능이 안정적입니다. 또한, 데이터의 삽입과 삭제가 빈번하게 일어나는 환경에서도 효과적입니다.

**예시**:\
만약 고객 테이블에서 고객의 나이를 기준으로 인덱스를 생성했다고 가정합시다. B-트리 인덱스는 나이 값에 따라 정렬된 구조를 유지하며, 특정 나이 범위에 해당하는 고객을 빠르게 검색할 수 있게 도와줍니다.

```sql
CREATE INDEX idx_age ON customers(age);
```

이 인덱스는 `customers` 테이블의 `age` 열에 대해 B-트리 구조의 인덱스를 생성합니다.

#### 4.5.4 인덱스 최적화 기법

인덱스는 성능 최적화에 매우 유용하지만, 잘못된 인덱스 설계나 관리로 인해 오히려 성능 저하를 초래할 수 있습니다. 이를 방지하기 위해 다음과 같은 인덱스 최적화 기법을 사용할 수 있습니다:

1. **인덱스는 비용이다**\
   인덱스를 생성하면 검색 성능은 향상되지만, 데이터 삽입, 업데이트, 삭제 시 추가적인 비용이 발생합니다. 따라서, 필요하지 않은 인덱스를 생성하지 않도록 주의해야 합니다. 예를 들어, 자주 검색되지 않는 열에 대해 인덱스를 생성하면, 이 인덱스를 유지하는 비용이 쿼리 성능 향상보다 더 클 수 있습니다.
2.  **항상 테스팅하라**\
    인덱스의 효과는 쿼리 패턴과 데이터 분포에 따라 달라집니다. 인덱스를 추가하기 전에 쿼리 성능을 분석하고, 인덱스가 실제로 성능 향상에 기여하는지 테스트하는 것이 중요합니다. 특히, 데이터베이스의 실행 계획을 확인하여 인덱스가 사용되는지 확인해야 합니다.

    ```sql
    EXPLAIN SELECT * FROM users WHERE email = 'example@example.com';
    ```

    이 명령어를 사용하면 쿼리 실행 계획을 확인할 수 있으며, 인덱스가 실제로 적용되고 있는지 알 수 있습니다.
3.  **복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다**\
    복합 인덱스(Composite Index)는 여러 열을 조합하여 하나의 인덱스로 만드는 것입니다. 복합 인덱스를 설계할 때는 쿼리의 `WHERE` 절이나 `ORDER BY` 절에서 가장 자주 사용되는 열을 먼저 배치해야 합니다. 특히, 필터링 조건으로 자주 사용되는 열을 선두에 두는 것이 중요합니다.

    ```sql
    CREATE INDEX idx_user_email_age ON users(email, age);
    ```

    이 인덱스는 `email`과 `age` 열에 대해 복합 인덱스를 생성하며, `email`을 기준으로 우선 검색한 후, 동일한 `email`을 가진 행에서 `age`를 기준으로 정렬합니다.
4.  **카디널리티(Cardinality)**\
    카디널리티는 특정 열에 있는 값의 고유한 수를 나타냅니다. 카디널리티가 높은 열(즉, 고유 값이 많은 열)에 인덱스를 생성하면 검색 성능이 더 크게 향상됩니다. 반면, 카디널리티가 낮은 열(즉, 중복 값이 많은 열)은 인덱스 생성의 이점이 적을 수 있습니다.

    예를 들어, 성별(Gender)처럼 값이 '남성'과 '여성' 두 개만 있는 열은 카디널리티가 낮기 때문에, 성별에 대한 인덱스는 큰 성능 향상을 기대하기 어렵습니다.

인덱스는 데이터베이스 성능 최적화의 핵심 요소이지만, 신중한 설계와 지속적인 모니터링이 필요합니다. 불필요한 인덱스는 제거하고, 중요한 쿼리에 대해 가장 적합한 인덱스를 적용하여 최적의 성능을 유지하는 것이 중요합니다.

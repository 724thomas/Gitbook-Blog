---
description: 5장. 서비스 추상화
---

# 5. User Level Management

**비즈니스 로직을 어디에 둘 것인가**, 그리고 **그 결정이 코드 구조와 테스트에 어떤 영향을 미치는가**를 단계적으로 체험하는 데 목적이 있습니다.

초반에는 `UserDao`에 레벨 관리 로직을 추가하면서 시작하지만, 점차 코드가 복잡해지고 책임이 뒤섞이면서 문제가 드러납니다.\
이를 해결하는 과정에서 다음과 같은 흐름을 거치게 됩니다.

* 단순한 데이터 표현(`int`)의 한계 인식
* 도메인 개념(`enum Level`) 도입
* 테스트를 통한 설계 문제 발견
* DAO와 Service 책임 분리
* 객체에게 책임을 이동시키는 리팩터링



## 5.1. 사용자 레벨 관리 기능 추가

기존 UserDao는 사용자 정보를 단순히 저장하고 조회하는 CRUD 기능만 제공하고 있었습니다.\
여기에 다음과 같은 **비즈니스 요구사항**이 추가됩니다.

* 사용자는 `BASIC`, `SILVER`, `GOLD` 중 하나의 레벨을 가집니다.
* 신규 가입 사용자는 항상 `BASIC` 레벨입니다.
* 로그인 횟수가 50회 이상이면 `SILVER`로 승급됩니다.
* 추천 횟수가 30회 이상이면 `GOLD`로 승급됩니다.
* 레벨 변경은 사용자의 행위가 아니라 **시스템이 정기적으로 수행하는 작업**입니다.
* 이미 승급된 사용자는 다시 처리되지 않습니다.

여기서 중요한 점은,\
&#xNAN;**“레벨”은 단순한 숫자나 상태값이 아니라, 명확한 규칙과 정책을 가진 비즈니스 개념**이라는 사실입니다.



### 5.1.1. 필드 추가

**int 타입으로 레벨을 표현할 때의 문제**

가장 먼저 떠올릴 수 있는 방식은 사용자 레벨을 `int`로 표현하는 것입니다.

```kotlin
class User {
    companion object {
        const val BASIC = 1
        const val SILVER = 2
        const val GOLD = 3
    }

    var level: Int = BASIC
}
```

이 방식은 구현이 간단해 보이지만, 설계적으로는 매우 위험합니다.

* `level = 1000` 같은 값도 아무 문제 없이 들어갈 수 있습니다.
* 컴파일러가 값의 의미를 전혀 보장해주지 않습니다.
* 코드만 보고 `1`, `2`, `3`이 무엇을 의미하는지 알기 어렵습니다.

즉, **타입이 비즈니스 규칙을 전혀 보호해주지 못하는 상태**입니다.

#### int 상수로도 충분해 보이는데, 왜 위험한가?

int 상수 방식은 컴파일 시점에 의미를 검증할 수 없다는 치명적인 문제가 있습니다.

* `User.setLevel(100)` 같은 코드가 문법적으로는 완벽히 유효합니다.
* 이는 “레벨이라는 개념이 숫자로 취급되고 있다”는 신호입니다.
* 비즈니스 개념이 원시 타입에 묻히면, 잘못된 값이 런타임까지 흘러가게 됩니다.

결국 이는 **테스트로도 막기 어려운 버그**로 이어집니다.

#### enum(Level) 도입과 도메인 모델링

이 문제를 해결하기 위해 `enum`을 도입합니다.

```kotlin
enum class Level(val value: Int) {
    BASIC(1),
    SILVER(2),
    GOLD(3);

    companion object {
        fun valueOf(value: Int): Level =
            values().find { it.value == value }
                ?: throw IllegalArgumentException("Unknown value: $value")
    }
}
```

이 설계의 핵심은 다음과 같습니다.

* 애플리케이션 내부에서는 **반드시 Level 타입만 사용**합니다.
* DB에는 여전히 `int`로 저장하지만, 그 사실은 외부로 드러나지 않습니다.
* 잘못된 값은 즉시 예외로 드러나도록 설계됩니다.

여기서 중요한 포인트는,\
**DB 설계와 도메인 모델을 동일시하지 않았다는 점**입니다.

#### 어차피 DB에는 int로 저장하는데, enum을 쓰는 실질적인 이점은?

상수 방식은 “값의 범위를 사람이 기억해야 하는 방식”입니다.\
컴파일러가 도와주지 않기 때문에, 잘못된 값은 항상 **런타임까지 흘러갑니다**.

반면 enum을 사용하면,

* 허용 가능한 값의 집합이 **타입 수준에서 고정**
* 잘못된 값은 **아예 코드 작성 단계에서 차단**
* 레벨과 관련된 행위를 함께 묶을 수 있는 여지가 생깁니다

이 차이는 **규모가 커질수록 치명적으로 벌어집니다**.

#### **Level enum 도입**

```kotlin
enum class Level(val value: Int) {
    BASIC(1),
    SILVER(2),
    GOLD(3);

    companion object {
        fun valueOf(value: Int): Level =
            when (value) {
                1 -> BASIC
                2 -> SILVER
                3 -> GOLD
                else -> throw AssertionError("Unknown value: $value")
            }
    }
}
```

이 설계의 핵심은 다음과 같습니다.

* DB에는 여전히 `int`로 저장
* 애플리케이션 내부에서는 **반드시 Level 타입으로만 사용**
* 잘못된 값은 즉시 예외 발생

즉, **DB 표현과 도메인 표현을 분리**한 구조입니다.

***

#### **User 클래스에 Level 필드 추가**

이제 `User` 클래스에 레벨 관련 필드를 추가합니다.

```kotlin
class User(
    val id: String,
    val name: String,
    val password: String,
    var level: Level,
    var login: Int,
    var recommend: Int
)
```

여기서 중요한 점은,

* 레벨은 단순 속성이 아니라
* 이후 **비즈니스 로직의 핵심 판단 기준**이 된다는 점입니다





### 5.1.2. 사용자 수정 기능 추가

**왜 수정 기능이 필요한가**

레벨 관리 로직을 테스트하려면,\
기존 사용자 정보를 **변경할 수 있어야** 합니다.

특히 레벨 업그레이드는 다음과 같은 특성을 가집니다.

* 사용자를 새로 생성하는 것이 아니라
* **기존 사용자의 상태를 변경**합니다

***

**update() 테스트부터 작성**

책에서는 이 시점에서도 **테스트를 먼저 수정**합니다.

* 사용자 하나를 저장
* 일부 필드를 변경
* 다시 조회해서 변경 여부 확인

이 테스트는 단순해 보이지만 update는 SELECT나 INSERT보다 훨씬 위험한 SQL입니다.

* WHERE 절이 빠지면 전체 데이터가 변경됩니다
* 컬럼 하나라도 누락되면 데이터 불일치가 발생합니다
* 컴파일 타임에 검증되지 않습니다



이 테스트가 검증하려는 시나리오는 다음과 같습니다.

1. 사용자 한 명을 DB에 저장한다
2. 그 사용자의 일부 필드를 변경한다
3. `update()`를 호출한다
4. 다시 조회해서 **모든 필드가 정확히 변경되었는지** 확인한다

```kotlin
@Test
fun update() {
    // given
    userDao.deleteAll()

    val user = User(
        id = "user1",
        name = "원래이름",
        password = "password1",
        level = Level.BASIC,
        login = 1,
        recommend = 0
    )

    userDao.add(user)

    // when - 일부 필드 변경
    user.name = "변경된이름"
    user.password = "password2"
    user.level = Level.GOLD
    user.login = 100
    user.recommend = 999

    userDao.update(user)

    // then - 다시 조회해서 검증
    val updatedUser = userDao.get(user.id)

    checkSameUser(user, updatedUser)
}

private fun checkSameUser(expected: User, actual: User) {
    assertThat(actual.id).isEqualTo(expected.id)
    assertThat(actual.name).isEqualTo(expected.name)
    assertThat(actual.password).isEqualTo(expected.password)
    assertThat(actual.level).isEqualTo(expected.level)
    assertThat(actual.login).isEqualTo(expected.login)
    assertThat(actual.recommend).isEqualTo(expected.recommend)
}
```

***

**UserDaoJdbc의 update 구현**

```kotlin
fun update(user: User) {
    jdbcTemplate.update(
        """
        update users
        set name = ?, password = ?, level = ?, login = ?, recommend = ?
        where id = ?
        """.trimIndent(),
        user.name,
        user.password,
        user.level.value,
        user.login,
        user.recommend,
        user.id
    )
}
```

이 코드에서 핵심은 다음 두 가지입니다.

* Level → DB 저장 시 `intValue()` 사용
* id를 기준으로 정확히 한 명만 수정

***

**테스트 보완: WHERE 절 검증**

초기 테스트는 다음 문제를 잡아내지 못합니다.

* `where id = ?`가 빠져도 테스트 통과 가능

그래서 책에서는 테스트를 보완합니다.

* 수정 대상 사용자 외의 사용자는 **절대 변경되지 않아야 함**
* 이 검증이 없다면 SQL 오류를 놓칠 수 있음

```kotlin
@Test
fun update_should_update_only_target_user() {
    // given
    userDao.deleteAll()

    val user1 = User(
        id = "user1",
        name = "user1",
        password = "password1",
        level = Level.BASIC,
        login = 1,
        recommend = 0
    )

    val user2 = User(
        id = "user2",
        name = "user2",
        password = "password2",
        level = Level.SILVER,
        login = 55,
        recommend = 10
    )

    userDao.add(user1)
    userDao.add(user2)

    // when - user1만 수정
    user1.name = "modified-name"
    user1.password = "modified-password"
    user1.level = Level.GOLD
    user1.login = 999
    user1.recommend = 999

    userDao.update(user1)

    // then
    val updatedUser1 = userDao.get(user1.id)
    val untouchedUser2 = userDao.get(user2.id)

    checkSameUser(user1, updatedUser1)
    checkSameUser(user2, untouchedUser2)
}
```

Where절이 없는 경우,

* user1은 기대대로 변경됨
* user2도 **같은 값으로 덮어써짐**
* `checkSameUser(user2, untouchedUser2)`에서 테스트 실패

#### update 테스트에서 왜 "다른 사용자가 변경되지 않았는지" 검증해야 하나?

SQL은 컴파일 타임에 검증되지 않습니다.\
WHERE 절이 빠진 UPDATE는 **모든 데이터를 변경**합니다.

이 오류는 기능 테스트만으로는 절대 잡히지 않으며,\
**의도하지 않은 데이터 파괴**로 이어질 수 있습니다.

DAO 테스트는 단순 성공 검증이 아니라\
**데이터 무결성 검증**이 목적입니다.



### 5.1.3. UserService.upgradeLevels()

**비즈니스 로직의 위치 문제**

이제 본격적인 문제가 드러납니다.

* 레벨 업그레이드는 명백한 비즈니스 로직
* 그런데 이 로직을 DAO에 넣기 시작하면
  * 조건 판단
  * 레벨 변경
  * DB 업데이트\
    가 한 클래스에 몰립니다

이 시점에서 **DAO의 책임이 무너지기 시작**합니다.

***

**UserService 도입**

책에서는 이 문제를 해결하기 위해 **UserService 클래스를 도입**합니다.

```kotlin
class UserService(
    private val userDao: UserDao
) {
    fun upgradeLevels() {
        val users = userDao.getAll()
        for (user in users) {
            if (user.level == Level.BASIC && user.login >= 50) {
                user.level = Level.SILVER
                userDao.update(user)
            } else if (user.level == Level.SILVER && user.recommend >= 30) {
                user.level = Level.GOLD
                userDao.update(user)
            }
        }
    }
}
```

이 구현은 아직 깔끔하지 않지만,\
**비즈니스 로직을 DAO 밖으로 끌어냈다는 점이 핵심**입니다.



#### 왜 이 로직을 DAO 두면 안되는가?

DAO는 “어떻게 저장하고 가져올 것인가”라는 **기술적 책임**만 가져야 합니다.\
레벨 업그레이드는 “언제 상태를 바꿀 것인가”라는 **정책 책임**입니다.

두 책임이 섞이면,

* 정책 변경이 기술 변경으로 전파되고
* 테스트가 복잡해지며
* 구현 교체(JDBC → JPA)가 어려워집니다

그래서 이 로직은 반드시 Service 계층에 위치해야 합니다.



### 5.1.4. UserService.add()

**신규 사용자 기본 레벨 문제**

새로운 요구사항이 등장합니다.

* 신규 가입자는 항상 BASIC 레벨이어야 한다

이 정책을 어디에 둘 것인지가 문제입니다.

* User 생성자?
* DAO add()?
* Service?

책에서는 **Service의 add() 메서드에서 처리**합니다.

```kotlin
fun add(user: User) {
    if (user.level == null) {
        user.level = Level.BASIC
    }
    userDao.add(user)
}
```

이 설계의 의미는 명확합니다.

* “기본 레벨 정책”은 **비즈니스 규칙**
* 따라서 Service가 책임진다



### 5.1.5. 코드 개선

**기존 upgradeLevels()의 한계**

기존 코드의 문제는 다음과 같습니다.

* if / else if 블록이 길고 읽기 어렵습니다
* 레벨 순서가 코드에 하드코딩되어 있습니다
* 레벨이 추가되면 조건문 전체를 수정해야 합니다

즉, **변경에 매우 취약한 구조**입니다.

***

**업그레이드 가능 여부 분리**

먼저 “업그레이드 가능한가”를 판단하는 메서드를 분리합니다.

```kotlin
private fun canUpgradeLevel(user: User): Boolean {
    return when (user.level) {
        Level.BASIC -> user.login >= 50
        Level.SILVER -> user.recommend >= 30
        Level.GOLD -> false
    }
}
```

이렇게 하면,

* 판단 로직과 실행 로직이 분리되고
* 테스트가 쉬워집니다

***

**Level에게 순서 책임 이동**

레벨의 순서를 `Level` enum이 스스로 알도록 변경합니다.

```kotlin
enum class Level(val value: Int, val next: Level?) {
    BASIC(1, SILVER),
    SILVER(2, GOLD),
    GOLD(3, null);

    fun nextLevel(): Level =
        next ?: throw IllegalStateException("업그레이드 불가")
}
```

***

**User에게 업그레이드 책임 이동**

```kotlin
fun upgradeLevel() {
    this.level = this.level.nextLevel()
}
```

Service는 이제 **결정만 하고 실행은 위임**합니다.

```kotlin
private fun upgradeLevel(user: User) {
    user.upgradeLevel()
    userDao.update(user)
}
```



#### 왜 Service가 직접 level을 변경하지 않고 User에게 위임하나?

User의 레벨은 User 자신의 상태입니다.\
외부에서 직접 변경하면 User는 단순한 데이터 구조가 됩니다.

상태 변경 책임을 객체에 두면,

* 상태 불변 조건을 내부에서 보호할 수 있고
* 잘못된 사용을 즉시 예외로 차단할 수 있으며
* 객체의 응집도가 높아집니다

이는 객체지향 설계의 핵심 원칙입니다.




---
description: 3장 템플릿
---

# 3. Template

## 3.1. 다시보는 초난감 DAO

초난감 DAO는 기능적으로는 동작하지만, 서버 환경에서 사용하기에는 여러 문제가 있습니다.\
DB 연결과 같은 제한된 리소스를 사용하는 코드임에도 불구하고, 예외 상황에 대한 고려가 부족해 안정성을 보장하지 못합니다. 특히 JDBC 코드에서는 정상 흐름이 아니라, 중간에 예외가 발생했을 때도 반드시 리소스를 반환해야 한다는 점이 중요합니다.

### 3.1.1. 예외처리 기능을 갖춘 DAO

JDBC 수정 기능의 예외 처리 문제\
가장 단순한 deleteAll() 메서드는 다음과 같은 구조를 가집니다.

* Connection 획득
* PreparedStatement 생성
* SQL 실행
* 리소스 close

문제는 SQL 실행 도중 예외가 발생하면 close 코드가 실행되지 않는다는 점입니다.\
이 경우 Connection과 PreparedStatent가 반환되지 않아, 커넥션 풀을 사용하는 서버 환경에서는 심각한 장애로 이어질 수 있습니다.

이 문제를 해결하기 위해 try/catch/finally 구조를 적용합니다.\
핵심은 어디서 예외가 발생하더라도 finally 블록에서 리소스를 정리하는 것입니다.

예외 상황을 고려한 deleteAll()

```kotlin
fun deleteAll() {
    var connection: Connection? = null
    var preparedStatement: PreparedStatement? = null

    try {
        connection = dataSource.connection
        preparedStatement = connection.prepareStatement("delete from users")
        preparedStatement.executeUpdate()
    } catch (e: SQLException) {
        throw e
    } finally {
        if (preparedStatement != null) {
            try {
                preparedStatement.close()
            } catch (e: SQLException) {
                // close 실패 시 별도 처리 없음
            }
        }
        if (connection != null) {
            try {
                connection.close()
            } catch (e: SQLException) {
                // close 실패 시 별도 처리 없음
            }
        }
    }
}
```

이 구조를 통해 예외가 발생하더라도 리소스가 반드시 반환됩니다. 다만 코드가 장황해지고, 메서드마다 유사한 패턴이 반복되는 문제가 발생합니다.

#### JDBC 조회 기능의 예외 처리

c조회 기능에서는 ResultSet이라는 리소스가 추가로 등장합니다. 따라서 정리해야 할 대상이 하나 더 늘어납니다. 이로 인해 try/catch/finally 블록은 더욱 복잡해집니다.

#### getCount() 메서드의 예외 처리

```kotlin
fun getCount(): Int {
    var connection: Connection? = null
    var preparedStatement: PreparedStatement? = null
    var resultSet: ResultSet? = null

    try {
        connection = dataSource.connection
        preparedStatement = connection.prepareStatement("select count(*) from users")
        resultSet = preparedStatement.executeQuery()
        resultSet.next()
        return resultSet.getInt(1)
    } catch (e: SQLException) {
        throw e
    } finally {
        if (resultSet != null) {
            try {
                resultSet.close()
            } catch (e: SQLException) {
            }
        }
        if (preparedStatement != null) {
            try {
                preparedStatement.close()
            } catch (e: SQLException) {
            }
        }
        if (connection != null) {
            try {
                connection.close()
            } catch (e: SQLException) {
            }
        }
    }
}
```

이 코드는 안정성은 확보했지만, 한계를 갖고 있습니다.

* 메서드마다 거의 동일한 try/catch/fainlly 코드가 반복됩니다.
* 비즈니스 로직보다 예외 처리 코드가 더 많습니다.
* 실수로 close 순서를 바꾸거나 누락할 수 있습니다.



## 3.2. 변하는 것과 변하지 않는 것

### 3.2.1. JDBC try/catch/finally 코드의 문제점

try/catch/finally를 적용한 DAO는 기능적으로는 안정적으로 실행할 수 있는 상태입니다.\
예외가 발생하더라도 리소스는 반환되고,\
서버 환경에서도 커넥션 누수 문제는 발생하지 않습니다.

하지만 코드를 조금만 확장해보면 문제가 발생: 중복 코드의 폭발적인 증가.

* 모든 DAO 메서드는 거의 동일한 try/catch/finally 구조를 가지고,
* ResultSet이 있느냐 없느냐 정도의 차이.
* 개발자는 copy & paste에 의존하게 됩니다.

이 방식은 아래의 위험들을 갖고 있습니다.

* close() 호출을 한 줄 빠뜨려도 컴파일 에러가 발생하지 않습니다.
* 정상 동작하는 것처럼 보이지만, 특정 경로에서만 커넥션이 반환되지 않을 수 있습니다.
* 서버에 배포된 뒤 일정 시간이 지나서야 DB 커넥션 풀이 고갈되는 장애로 이어질 수 있습니다.

실제 기업환경에서는 이런 문제로 서버 재가동이나 긴급 장애 대응이 발생하는 사례가 존재합니다.&#x20;

문제는:&#x20;

* 코드 자체가 틀렸다고 바로 드러나지는 앖다는 것이고,
* 테스트로 검증하려 해도 예외 상황을 만들기 어렵고,
* DAO 메서드마다 모든 예외 케이스를 테스트하는 것은 현실적으로 힘듭니다.



### 3.2.2. 분리와 재사용을 위한 디자인 패턴 적용

이 문제를 해결하기 위해 "변하는 것과 변하지 않는 것을 식별"합니다.

deleteAll()을 기준으로 보면 아래와 같이 나눌 수 있습니다.

* 변하지 않는 부분
  * Connection 획득
  * PreparedStatement 실행
  * 예외 처리
  * 리소스 반환 (try/catch/finally)
* 변하는 부분
  * PreparedStatement 생성 로직
  * SQL 문자열
  * 파라미터 바인딩 방식

#### 메서드 추출

```kotlin
fun deleteAll() {
    var connection: Connection? = null
    var ps: PreparedStatement? = null

    try {
        connection = dataSource.connection
        ps = makeStatement(connection)
        ps.executeUpdate()
    } catch (e: SQLException) {
        throw e
    } finally {
        if (ps != null) ps.close()
        if (connection != null) connection.close()
    }
}

private fun makeStatement(connection: Connection): PreparedStatement {
    return connection.prepareStatement("delete from users")
}
```

이렇게 분리하게 되면 SQL 생성 로직은 분리되지만, 실제로는 재사용성 측면에서 이득은 없습니다.\
왜냐하면 재사용이 필요한 쪽은 try/catch/finally 구조인데, 이 구조는 완전히 DAO 메서드 안에 고정되어 있기 때문입니다.

#### 템플릿 메서드 패턴

변하지 않는 흐름을 슈퍼클래스에 두고, 변하는 부분을 추상 메서드로 정의해 서브클래스에서 구현합니다.

```kotlin
abstract class UserDao {

    fun deleteAll() {
        var connection: Connection? = null
        var ps: PreparedStatement? = null

        try {
            connection = dataSource.connection
            ps = makeStatement(connection)
            ps.executeUpdate()
        } finally {
            if (ps != null) ps.close()
            if (connection != null) connection.close()
        }
    }

    protected abstract fun makeStatement(connection: Connection): PreparedStatement
}

```

```kotlin
예시 하위클래스
import java.sql.Connection
import java.sql.PreparedStatement

class UserDaoDeleteAll(
    dataSource: DataSource
) : UserDao(dataSource) {

    override fun makeStatement(connection: Connection): PreparedStatement {
        return connection.prepareStatement("delete from users")
    }
}
```



이 방식은 중복 제거에는 성공하지만, 상속 기반 확장이라는 한계를 가집니다.

* DAO 기능 하나 추가할 때마다 서브클래스가 필요합니다.
* 클래스 개수가 빠르게 증가합니다.
* 런타임에 유연학헤 동작을 바꾸기 어렵습니다.

즉, 구조가 컴파일 시점에 고정되어 버립니다.

#### 전략 패턴

이를 해결하기 위해 등장한 것이 전략 패턴입니다.\
변하는 부분을 인터페이스로 분리하고, 이를 외부에서 주입받도록 합니다.

```kotlin
interface StatementStrategy {
    fun makePreparedStatement(connection: Connection): PreparedStatement
}
```

```kotlin
class DeleteAllStatement : StatementStrategy {
    override fun makePreparedStatement(connection: Connection): PreparedStatement {
        return connection.prepareStatement("delete from users")
    }
}
```

이제 try/catch/finally 구조는 컨텍스트로 분리됩니다.

```kotlin
fun jdbcContextWithStatementStrategy(strategy: StatementStrategy) {
    var connection: Connection? = null
    var ps: PreparedStatement? = null

    try {
        connection = dataSource.connection
        ps = strategy.makePreparedStatement(connection)
        ps.executeUpdate()
    } finally {
        if (ps != null) ps.close()
        if (connection != null) connection.close()
    }
}
```

deleteAll()은 더 이상 JDBC구조를 알 필요가 없습니다.

```kotlin
fun deleteAll() {
    jdbcContextWithStatementStrategy(DeleteAllStatement())
}
```



## 3.3 JDBC 전략 패턴의 최적화

deleteAll()을 전략 패턴으로 분리한 이후, JDBC 작업의 공통 흐름은 \
jdbcContextWithStatementStrategy() 라는 컨텍스트 메서드로 모였습니다.\
DAO 메서드는 이제 SQL과 파라미터 설정같은 "변하는 로직"만 책임지게 되었고, 예외 처리와 리소스 관리는 컨텍스트가 담당합니다.

* 컨텍스트: JDBC 작업의 고정된 흐름 담당
* 전략: PreparedStatement 생성이라는 가변 로직 담당

이제 이 구조를 add() 메서드에도 적용하면서, 실제 사용 과정에서 드러나는 문제를 하나씩 해결해 나갑니다.

### 3.3.1. 전략 클래스의 추가 정보

deletreAll()과 달리 add()는 PreparedStatement를 만들 때 User라는 추가 정보가 필요합니다.\
전략 클래스를 분리하면 가장 먼저 해결해야하는 문제는:

"전략 클래스 안에서 user 객체를 어떻게 사용할 것인가?" 입니다.

해결 방법은, 전략 클래스가 필요한 정보를 생성자를 통해 전달받도록 만드는 것입니다.

```kotlin
class AddStatement(private val user: User) : StatementStrategy {
    override fun makePreparedStatement(c: Connection): PreparedStatement {
        val ps = c.prepareStatement(
            "insert into users(id, name, password) values(?,?,?)"
        )
        ps.setString(1, user.id)
        ps.setString(2, user.name)
        ps.setString(3, user.password)
        return ps
    }
}
```

그리고 DAO 메서드는 전략 객체를 생성해서 컨텍스트에 전달합니다.

```kotlin
fun add(user: User) {
    val strategy = AddStatement(user)
    jdbcContextWithStatementStrategy(strategy)
}
```

이 방식으로 기능은 정상 동작하지만, 또 다른 문제가 생깁니다.

* DAO 메서드마다 전략 클래스를 하나씩 만들어야 합니다.
* 클래스 파일 수가 늘어납니다.
* 전략 클래스는 특정 DAO 메서드에만 강하게 결합되어 있습니다.

### 3.3.2. 전략과 클라이언트의 동거

이 문제를 해결하는 첫 번째 개선은 **전략 클래스를 외부 파일로 분리하지 않는 것**입니다.\
전략이 특정 DAO 메서드에서만 사용된다면, 굳이 독립 클래스로 둘 필요가 없습니다.

#### 로컬 클래스 적용

전략 클래스를 DAO 메서드 내부의 로컬 클래스로 옮길 수 있습니다.

```kotlin
fun add(user: User) {
    class AddStatement(private val user: User) : StatementStrategy {
        override fun makePreparedStatement(c: Connection): PreparedStatement {
            val ps = c.prepareStatement(
                "insert into users(id, name, password) values(?,?,?)"
            )
            ps.setString(1, user.id)
            ps.setString(2, user.name)
            ps.setString(3, user.password)
            return ps
        }
    }

    jdbcContextWithStatementStrategy(AddStatement(user))
}
```

이렇게 하면 아래의 효과를 얻습니다.

* 클래스 파일 수 감소
* 전략의 사용 범위가 명확해짐
* 코드의 응집도가 높아짐

하지만 여전히 코드가 깁니다.

#### 익명 내부 클래스

로컬 클래스에서 한 단계 더 나아가면 익명 내부 클래스를 사용할 수 있습니다.\
전략 인터페이스를 구현하는 객체를 즉석에서 만들어 전달하는 방식입니다.

```kotlin
fun add(user: User) {
    jdbcContextWithStatementStrategy(
        object : StatementStrategy {
            override fun makePreparedStatement(c: Connection): PreparedStatement {
                val ps = c.prepareStatement(
                    "insert into users(id, name, password) values(?,?,?)"
                )
                ps.setString(1, user.id)
                ps.setString(2, user.name)
                ps.setString(3, user.password)
                return ps
            }
        }
    )
}
```

deleteAll()도 같은 방식으로 정리할 수 있습니다.

```kotlin
fun deleteAll() {
    jdbcContextWithStatementStrategy(
        object : StatementStrategy {
            override fun makePreparedStatement(c: Connection): PreparedStatement {
                return c.prepareStatement("delete from users")
            }
        }
    )
}
```

이제 전략 패턴의 구조는 유지하면서도 클래스 폭증 문제와 가독성 문제를 동시에 해결했습니다.

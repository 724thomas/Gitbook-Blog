---
description: 6장 AOP
---

# 6. AOP

## 6.1. 트랜잭션 코드의 분리

### 6.1.1. 메서드 분리

기존 `upgradeLevels()` 메서드는 다음과 같은 구조였습니다.

* 트랜잭션 시작
* 비즈니스 로직 실행
* 커밋 또는 롤백

즉, **트랜잭션 경계설정 코드 + 비즈니스 로직**이 하나의 메서드 안에 공존하고 있습니다.

```kotlin
fun upgradeLevels() {
    val status = transactionManager.getTransaction(DefaultTransactionDefinition())

    try {
        val users = userDao.getAll()
        for (user in users) {
            if (canUpgradeLevel(user)) {
                upgradeLevel(user)
            }
        }
        transactionManager.commit(status)
    } catch (e: Exception) {
        transactionManager.rollback(status)
        throw e
    }
}
```

여기서 눈에 띄는 문제는 다음입니다.

* 트랜잭션 코드가 로직의 앞뒤를 감싸고 있음
* 비즈니스 로직이 기술 코드에 의해 오염됨
* 수정 시 실수 위험 증가

**1차 개선 – 내부 메서드로 분리**

비즈니스 로직을 별도 메서드로 분리합니다.

```kotlin
fun upgradeLevels() {
    val status = transactionManager.getTransaction(DefaultTransactionDefinition())
    try {
        upgradeLevelsInternal()
        transactionManager.commit(status)
    } catch (e: Exception) {
        transactionManager.rollback(status)
        throw e
    }
}

private fun upgradeLevelsInternal() {
    val users = userDao.getAll()
    for (user in users) {
        if (canUpgradeLevel(user)) {
            upgradeLevel(user)
        }
    }
}
```

이렇게 하면 다음과 같은 효과가 있습니다.

* 트랜잭션 경계설정 코드가 위로 정리됨
* 비즈니스 로직이 한눈에 들어옴
* 가독성 향상

하지만 여전히 **같은 클래스 안에 트랜잭션 코드가 존재**합니다.



### 6.1.2. DI를 이용한 클래스의 분리

UserService는 비즈니스 로직만 담당해야 하는데, 트랜잭션이라는 기술 코드가 포함되어 있다.

**구조 변경 목표**

* UserServiceImpl → 순수 비즈니스 로직만 담당
* UserServiceTx → 트랜잭션 경계설정만 담당

이를 위해 먼저 인터페이스를 도입합니다.

```kotlin
interface UserService {
    fun add(user: User)
    fun upgradeLevels()
}
```

***

#### UserServiceImpl – 순수 비즈니스 로직

```kotlin
class UserServiceImpl(
    private val userDao: UserDao,
    private val mailSender: MailSender
) : UserService {

    override fun add(user: User) {
        userDao.add(user)
    }

    override fun upgradeLevels() {
        val users = userDao.getAll()
        for (user in users) {
            if (canUpgradeLevel(user)) {
                upgradeLevel(user)
            }
        }
    }
}
```

이제 이 클래스에는 다음이 없습니다.

* transactionManager
* commit
* rollback
* DefaultTransactionDefinition

완전히 기술 코드가 제거되었습니다.

***

#### UserServiceTx – 트랜잭션 전담 클래스

```kotlin
class UserServiceTx(
    private val userService: UserService,
    private val transactionManager: PlatformTransactionManager
) : UserService {

    override fun add(user: User) {
        userService.add(user)
    }

    override fun upgradeLevels() {
        val status = transactionManager.getTransaction(DefaultTransactionDefinition())

        try {
            userService.upgradeLevels()
            transactionManager.commit(status)
        } catch (e: RuntimeException) {
            transactionManager.rollback(status)
            throw e
        }
    }
}
```

여기서 중요한 점은 다음입니다.

* UserServiceTx는 비즈니스 로직을 모름
* 단지 위임(delegate)만 수행
* upgradeLevels() 호출 전후에 트랜잭션 처리

이 구조는 **데코레이터 패턴**과 매우 유사합니다.

***

#### DI 설정의 의미

이제 클라이언트는 다음 구조로 동작합니다.

```
Client → UserServiceTx → UserServiceImpl
```

즉,

* 외부에서 보기에는 UserService 하나
* 실제로는 트랜잭션 기능이 덧붙여진 구조

스프링 설정은 다음과 같은 개념입니다.

* userService 빈 → UserServiceTx
* userServiceImpl 빈 → 실제 비즈니스 로직
* transactionManager → UserServiceTx에 주입

***

#### 트랜잭션 분리 후 테스트 수정

구조가 바뀌면 테스트도 바뀝니다.

이전에는 `UserServiceImpl`을 직접 테스트했습니다.\
이제는 트랜잭션 기능이 포함된 `UserServiceTx`를 테스트해야 합니다.

테스트에서 수동 DI를 구성하면 다음과 같습니다.

```kotlin
val testUserService = TestUserService()
val txUserService = UserServiceTx(testUserService, transactionManager)
```

그리고 트랜잭션이 롤백되는지 검증합니다.

여기서 중요한 포인트는 다음입니다.

* 트랜잭션 테스트는 비즈니스 테스트와 다름
* 트랜잭션 경계설정이 정상 동작하는지 검증
* 구조 변경에 따라 테스트도 변경되어야 함

***

#### 트랜잭션 경계설정 코드 분리의 장점

이 분리를 통해 얻는 가장 큰 장점은 다음입니다.

**1. 비즈니스 로직의 순수성 확보**

UserServiceImpl은 이제 다음에만 집중합니다.

* 사용자 레벨 업그레이드 조건
* 상태 변경
* 메일 발송

기술 코드와 완전히 분리되었습니다.

***

**2. 기술 교체 가능성 확보**

* JTA
* JDBC 트랜잭션
* 다른 트랜잭션 전략

비즈니스 로직을 건드리지 않고 교체 가능해집니다.

***

**3. 트랜잭션 적용 대상 확장 가능**

같은 방식으로 다른 서비스에도 트랜잭션 기능을 붙일 수 있습니다. 트랜잭션은 횡단 관심사(Cross-Cutting Concern)입니다.





## 6.2. 고립된 단위 테스트

### 6.2.1. 복잡한 의존관계 속의 테스트

`UserService`는 단순해 보이지만 실제로는 다음 의존성을 가집니다.

* UserDao → DB, DataSource, JDBC Driver
* PlatformTransactionManager → 트랜잭션 인프라
* MailSender → JavaMail, 메일 서버

즉, UserService 테스트는 다음을 함께 테스트하는 것과 같습니다.

* DB 서버
* 트랜잭션 매니저
* 메일 서버
* 네트워크 환경

이건 더 이상 단위 테스트가 아닙니다.

문제점은 다음과 같습니다.

* 테스트 속도가 느림
* 환경 의존성 발생
* 실패 원인 추적 어려움
* DB 상태에 따라 결과가 달라질 수 있음



### 6.2.2. 6.2 고립된 단위 테스트

이번 절에서는 **테스트를 가능한 한 작은 단위로 분리하는 방법**과, 그 과정에서 등장하는 **목(Mock) 객체와 Mockito의 활용**까지 정리합니다.\
핵심은 다음 한 문장으로 요약할 수 있습니다.

> 테스트는 작게, 의존성은 제거하고, 행위만 검증한다.

***

#### 요약

* 작은 단위 테스트는 실패 원인 파악이 쉽고 빠르다.
* UserService는 겉보기보다 많은 외부 의존성을 가진다.
* 의존 객체(DB, 트랜잭션, 메일 서버 등)를 제거하지 않으면 진짜 단위 테스트가 아니다.
* 이를 해결하기 위해 스텁(Stub)과 목(Mock) 객체를 사용한다.
* Mockito는 목 객체를 매우 간단하게 만들어준다.

***

#### 6.2.1 복잡한 의존관계 속의 테스트

`UserService`는 단순해 보이지만 실제로는 다음 의존성을 가집니다.

* UserDao → DB, DataSource, JDBC Driver
* PlatformTransactionManager → 트랜잭션 인프라
* MailSender → JavaMail, 메일 서버

즉, UserService 테스트는 다음을 함께 테스트하는 것과 같습니다.

* DB 서버
* 트랜잭션 매니저
* 메일 서버
* 네트워크 환경

이건 더 이상 단위 테스트가 아닙니다.

문제점은 다음과 같습니다.

* 테스트 속도가 느림
* 환경 의존성 발생
* 실패 원인 추적 어려움
* DB 상태에 따라 결과가 달라질 수 있음

#### 6.2.2 테스트 대상 오브젝트 고립시키기

진짜 단위 테스트를 만들기 위해서는 테스트 대상 외의 모든 것을 가짜 객체로 바꿔야합니다.

* DB 대신 MockUserDao
* 메일 서버 대신 MockMailSender
* 트랜잭션은 이미 분리되었으므로 제거 가능

#### 기존 방식 (DB 의존 테스트)

```kotlin
@Test
fun upgradeLevels() {
    userDao.deleteAll()
    users.forEach { userDao.add(it) }

    userService.upgradeLevels()

    checkLevelUpgraded(users[1], true)
}
```

이 테스트는 DB에 의존합니다.

#### 고립된 테스트 구조

이제 UserServiceImpl만 직접 생성합니다.

```kotlin
val userService = UserServiceImpl()
val mockUserDao = MockUserDao(users)
userService.userDao = mockUserDao

val mockMailSender = MockMailSender()
userService.mailSender = mockMailSender

userService.upgradeLevels()
```

이제 DB가 필요 없습니다.

***

#### MockUserDao 구현

```kotlin
class MockUserDao(private val users: List<User>) : UserDao {

    val updated = mutableListOf<User>()

    override fun getAll(): List<User> = users

    override fun update(user: User) {
        updated.add(user)
    }

    override fun add(user: User) {
        throw UnsupportedOperationException()
    }

    override fun deleteAll() {
        throw UnsupportedOperationException()
    }

    override fun get(id: String): User {
        throw UnsupportedOperationException()
    }

    override fun getCount(): Int {
        throw UnsupportedOperationException()
    }
}
```

핵심은 다음입니다.

* getAll() → 테스트용 사용자 반환
* update() → 호출된 사용자 기록
* 나머지 메서드 → 사용되면 예외 발생

***

#### 검증 코드

```kotlin
val updated = mockUserDao.updated

assertThat(updated.size).isEqualTo(2)
assertThat(updated[0].id).isEqualTo("joytouch")
assertThat(updated[0].level).isEqualTo(Level.SILVER)
assertThat(updated[1].id).isEqualTo("madnite1")
assertThat(updated[1].level).isEqualTo(Level.GOLD)
```

이제 DB를 확인할 필요가 없습니다.

#### 테스트 성능 비교

* DB 사용하는 테스트: 0.25초,&#x20;
* 고립 테스트: 0.001초 이하로 차이가 큽니다.

테스트가 커질수록 실행 속도 차이가 큽니다.



### 6.2.3. 단위 테스트와 통합 테스트

정리하면 다음과 같습니다.

**단위 테스트**

* 외부 의존성 제거
* 빠름
* 안정적
* 행위 검증 중심

**통합 테스트**

* 여러 객체가 함께 동작
* DB, 네트워크 포함 가능
* 느림
* 환경 의존적

가이드라인은 다음입니다.

* 항상 단위 테스트를 먼저 고려한다.
* DAO는 통합 테스트로 검증해도 된다.
* 외부 리소스를 사용하는 테스트는 최소화한다.



#### 6.2.4 목 프레임워크 – Mockito

목 객체를 직접 구현하면 번거롭습니다.

Mockito를 사용하면 매우 간단해집니다.

#### Mockito 기본 사용법

```kotlin
val mockUserDao = mock(UserDao::class.java)

`when`(mockUserDao.getAll()).thenReturn(users)

verify(mockUserDao, times(2)).update(any(User::class.java))
```

#### MailSender 검증

```kotlin
val mockMailSender = mock(MailSender::class.java)

verify(mockMailSender, times(2)).send(any())
```

#### ArgumentCaptor 사용 예시

```kotlin
val mailCaptor = ArgumentCaptor.forClass(SimpleMailMessage::class.java)

verify(mockMailSender, times(2)).send(mailCaptor.capture())

val messages = mailCaptor.allValues
assertThat(messages[0].to[0]).isEqualTo(users[1].email)
assertThat(messages[1].to[0]).isEqualTo(users[3].email)
```

#### Mockito가 해주는 일

* 인터페이스 구현 자동 생성
* 호출 횟수 검증
* 파라미터 검증
* 반환값 설정
* 예외 강제 발생 가능

직접 Mock 클래스를 작성할 필요가 거의 없습니다.





## 6.3. 다이나믹 프록시와 팩토리 빈

6.1에서 트랜잭션 경계설정 코드를 비즈니스 로직에서 분리하기 위해 `UserServiceTx` 같은 클래스를 도입했지만, **프록시(위임 + 부가기능) 클래스가 많아질수록 중복과 관리 비용이 폭증**합니다. 6.3은 이 문제를 해결하기 위해 다음 흐름으로 전개됩니다.

* **프록시/데코레이터 패턴으로 “부가기능(트랜잭션)”을 핵심 로직 밖으로 분리**합니다.
* 그러나 정적(클래스) 프록시는 인터페이스 메서드를 모두 구현해야 해서 **메서드 수가 늘면 코드가 기하급수적으로 증가**합니다.
* 이를 해결하기 위해 **JDK 다이나믹 프록시**를 사용하고, 내부에서 **리플렉션(Method.invoke)** 으로 호출을 위임합니다.
* 다이나믹 프록시는 “스프링 빈”으로 바로 등록하기가 애매한데(클래스가 런타임에 생성됨), 이를 해결하기 위해 **팩토리 빈(FactoryBean)** 을 사용합니다.
* 팩토리 빈 방식은 “프록시 생성 코드”를 설정/DI로 숨겨 재사용성을 높이지만, **설정 중복(XML 폭발)** 과 **핸들러(부가기능 객체) 중복**이라는 한계도 함께 드러납니다.

### 6.3.1. 프록시와 프록시 패턴, 데코레이터 패턴

"부가기능"을 코드에서 분리한다.\
트랜잭션은 사용자 관리 비즈니스 로직과 성격이 다릅니다.\
그래서

* 트랜잭션 적용은 비즈니스 클래스 밖으로 빼고,
* 핵심 코드는 핵심남 남기도록 하여

부가기능은 별도 객체가 담당하게 만들 수 있습니다.

구조:

* 클라이언트 -> 프록시 -> 타깃
* 프록시는 타깃과 같은 인터페이스를 구현
* 클라이언트는 프록시를 타깃처럼 사용하지만, 실제로는 프록시가 타깃 호출 전/후에 부가기능을 수행

#### 데코레이터 패턴

데코레이터는 "타깃에 부가기능을 런타임에 겹겹이 붙이는 방식"입니다.

* 프록시(데코레이터)들은 보통 같은 인터페이스를 구현합니다.
* 여러 데코레이터를 체인으로 조합해 부가기능을 단계적으로 적용할 수 있습니다.
* 대표 예로 IO의 InputStream / OutputStream 등이 자주 언급됨

UserServiceTx는 "트랜잭션 부가기능을 제공하는 데코레이터"로 볼 수 있습니다. UserServiceTx가 UserService를 구현하고 내부에 실제 로직 객체(UserServiceImpl)를 두고 위임하기 때문입니다.

#### 프록시 패턴

* 접근 제어(권한/ 지연 로딩/원격 호출 등)
* 타깃에 기능을 "추가"하기보다, 타깃에 접근하는 방법 자체를 바꾼다는 관점이 핵심.

#### 그럼 인터셉터도 데코레이터 패턴인가?

구조만 보면 "호출을 가로채서 전/후 처리를 한다"는 점에서 데코레이터/프록시와 유사합니다.\
다만 인터셉터는 보통 프레임워크가 제공하는 호출 체인(Chain of Responsibility)위에서 동작하고, "객체를 감싼다(래핑한다)"기 보다 호출 흐름에 참여한다" 는 성격이 강함.

스프링 AOP의 MethodIntercepter도 이름은 인터셉터지만, 실제 구현은 프록시 기반 호출 가로채기에 가까움.

#### 6.3.2. 다이나믹 프록시

프록시를 젝접 만들 때의 문제(왜 다이나믹이 필요한가)

UserServiceTx같은 정적 프록시는 아래 두 가지 성격의 코드가 한 클래스에 공존합니다.

1. 인터페이스 메서드 구현 + 위임 코드
   1. 인터페이스가 커질수록 "그냥 위임하는 메서드"가 폭증.
2. 부가기능 코드(트랜잭션 경계)
   1. 트랜잭션을 적용할 메서드가 늘면 유사한 로직이 반복됩니다.

즉, "메서드가 늘수록" 위임 코드가 늘고, "트랜잭션 적용 지점이 늘수록" 부가기능 코드도 늘어납니다.

#### 리플랙션

다이나믹 프록시는 리플랙션을 사용합니다. 리플랙션은 "클래스/메서드/필드 같은 코드의 구조 정보를 런타임에 다루는 기술"

* String::class.java 또는 String::class.java.getMethod("length") 처럼 메서드 메타데이터를 얻을 수 있습니다.
* 얻은 Method에 대해 invoke(대상 객체, 인자...)로 호출할 수 있습니다.
* 컴파일 시점에 obj.length()를 호출하는 코드 대신 런타임에 메서드를 찾아 호출 할 수 있습니다.

```kotlin
import java.lang.reflect.Method
import kotlin.test.Test
import kotlin.test.assertEquals

class ReflectionTest {

    @Test
    fun invokeMethod() {
        val name = "Spring"

        // 일반 호출
        assertEquals(6, name.length)

        // 리플렉션으로 Method 획득 후 호출
        val lengthMethod: Method = String::class.java.getMethod("length")
        val result = lengthMethod.invoke(name) as Int
        assertEquals(6, result)

        // 파라미터가 있는 메서드도 동일
        val charAtMethod: Method = String::class.java.getMethod("charAt", Int::class.javaPrimitiveType)
        val ch = charAtMethod.invoke(name, 0) as Char
        assertEquals('S', ch)
    }
}
```

#### 다이나믹 프록시의 핵심 구조

JDK 다이나믹 프록시의 대략 적인 흐름:

* 프록시 객체는 Proxy.newProxyInstance(..)로 런타임에 생성됩니다.
* 프록시가 인터페이스 메서드를 호출받으면, 내부적으로 InvocationHandler.invoke(...) 한 곳으로 모입니다.
* invoke(proxy, method, args)에서 method.invoke(target, args)로 타깃 호출을 수행하고,
* 그 전/후 부가기능을 끼워 넣습니다.

```kotlin
interface Hello {
    fun sayHello(name: String): String
    fun sayHi(name: String): String
    fun sayThankYou(name: String): String
}

class HelloTarget : Hello {
    override fun sayHello(name: String) = "Hello $name"
    override fun sayHi(name: String) = "Hi $name"
    override fun sayThankYou(name: String) = "Thank You $name"
}
```

정적 프록시(대문자 변환)를 먼저 만들면 이런 형태입니다(메서드가 늘수록 중복이 늘어나는 예시).

```kotlin
class HelloUppercase(private val target: Hello) : Hello {
    override fun sayHello(name: String): String = target.sayHello(name).uppercase()
    override fun sayHi(name: String): String = target.sayHi(name).uppercase()
    override fun sayThankYou(name: String): String = target.sayThankYou(name).uppercase()
}
```

다이나믹 프록시는 이 중복을 `InvocationHandler` 하나로 모읍니다.

```kotlin
import java.lang.reflect.InvocationHandler
import java.lang.reflect.Method

class UppercaseHandler(private val target: Any) : InvocationHandler {
    override fun invoke(proxy: Any, method: Method, args: Array<out Any>?): Any? {
        val result = if (args == null) method.invoke(target) else method.invoke(target, *args)
        return if (result is String) result.uppercase() else result
    }
}
```

프록시 생성은 다음처럼 됩니다.

```kotlin
import java.lang.reflect.Proxy

fun createHelloProxy(target: Hello): Hello {
    return Proxy.newProxyInstance(
        Hello::class.java.classLoader,
        arrayOf(Hello::class.java),
        UppercaseHandler(target)
    ) as Hello
}

```

#### “리플렉션은 왜 이렇게까지 하나?”

핵심은 **중복 제거의 단위가 ‘메서드’에서 ‘호출 1회’로 바뀌는 것** \
정적 프록시는 인터페이스의 메서드 개수만큼 코드를 만들어야 하지만, 다이나믹 프록시는 “호출이 들어오면 invoke로 모인다”는 구조 덕분에, 메서드 수가 늘어도 프록시 코드(핸들러)는 거의 변하지 않습니다.&#x20;

즉, 다이나믹 프록시는 “코드 생성(프록시 클래스 작성)”을 런타임으로 밀어 넣고, “호출 처리 로직(부가기능 적용)”을 핸들러로 일반화합니다.



### 6.3.3. 다이나믹 프록시를 이용한 트랜잭션 부가기능

**트랜잭션 InvocationHandler**

트랜잭션 부가기능은 “특정 메서드 호출에 대해 트랜잭션을 시작/커밋/롤백”하는 구조입니다. 다이나믹 프록시로 만들면 다음 포인트가 중요합니다.

* 어떤 메서드에 트랜잭션을 적용할지 결정해야 합니다.
* 타깃 호출은 `method.invoke(target, args)`로 처리합니다.
* 예외 처리에서 리플렉션 호출의 예외 래핑(`InvocationTargetException`)을 고려해야 합니다.

책에서는 “메서드 이름 패턴”을 이용해 적용 대상을 고릅니다. 예를 들어 `upgradeLevels` 같은 특정 이름(또는 `get*` 같은 패턴)에만 트랜잭션을 적용합니다.

```kotlin
import org.springframework.transaction.PlatformTransactionManager
import org.springframework.transaction.TransactionStatus
import org.springframework.transaction.support.DefaultTransactionDefinition
import java.lang.reflect.InvocationHandler
import java.lang.reflect.InvocationTargetException
import java.lang.reflect.Method

class TransactionHandler(
    private var target: Any,
    private val transactionManager: PlatformTransactionManager,
    private val pattern: String, // 예: "upgradeLevels" 또는 "get"
) : InvocationHandler {

    override fun invoke(proxy: Any, method: Method, args: Array<out Any>?): Any? {
        // 패턴이 맞지 않으면 트랜잭션 없이 그대로 위임
        if (!method.name.startsWith(pattern)) {
            return invokeTarget(method, args)
        }

        // 트랜잭션 적용
        val status: TransactionStatus =
            transactionManager.getTransaction(DefaultTransactionDefinition())

        return try {
            val ret = invokeTarget(method, args)
            transactionManager.commit(status)
            ret
        } catch (e: InvocationTargetException) {
            transactionManager.rollback(status)
            // 리플렉션 호출에서 타깃 예외는 InvocationTargetException으로 감싸지므로 원인 예외를 꺼냄
            throw e.targetException
        } catch (e: RuntimeException) {
            transactionManager.rollback(status)
            throw e
        }
    }

    private fun invokeTarget(method: Method, args: Array<out Any>?): Any? {
        return if (args == null) method.invoke(target) else method.invoke(target, *args)
    }
}
```

핵심은 `invoke()`에서 **트랜잭션 적용 여부를 결정**하고, 적용 대상이면 트랜잭션 경계를 잡은 뒤, `method.invoke(...)`로 타깃을 실행한다는 점입니다.



#### “@Transactional이 private에 안 붙는 이유가 ‘private이라서 호출이 안 돼서’인가요?”

결론부터 말하면, “프록시가 가로챌 수 있는 호출 형태가 아니기 때문”이 핵심입니다.&#x20;

`private`은 ‘호출이 불가능’이 아니라 ‘클래스 내부에서만 호출 가능’인데, 문제는 **내부 호출(self-invocation)** 은 프록시를 거치지 않는다는 점입니다. \
트랜잭션이 붙는 방식이 “프록시가 public 메서드 호출을 가로채서 부가기능을 적용”하는 구조라면, 같은 객체 내부에서 `this.privateMethod()`를 호출해도 프록시 바깥에서 프록시를 통해 들어오는 호출이 아니므로 트랜잭션 어드바이스가 끼어들 틈이 없어집니다.&#x20;

(여기서 “private이면 호출이 안 된다”가 아니라 “프록시 경유 호출이 아니다”가 정확한 설명입니다.)



### 6.3.4 다이나믹 프록시를 위한 팩토리 빈

**왜 “팩토리 빈”이 필요한가**

다이나믹 프록시는 스프링이 평소 하던 방식(클래스 이름으로 빈을 만들고, 리플렉션으로 생성자를 호출해 인스턴스 생성)과 다릅니다.

* 스프링의 기본 빈 등록은 “클래스가 고정”이고 “생성 방법이 일반적(생성자/팩토리 메서드)”인 경우가 많습니다.
* 다이나믹 프록시는 `Proxy.newProxyInstance(...)` 호출로 **런타임에 생성되는 클래스**입니다.
* 즉, “이 프록시 객체의 클래스는 무엇인가?”를 미리 딱 잘라 빈 정의로 적기가 곤란합니다.
* 그래서 “스프링이 빈을 만들 때 사용할 생성 로직을 대신 제공하는 빈”이 필요해지고, 그 역할이 **FactoryBean** 입니다.

책에서 든 예로, 생성자가 private인 클래스는 스프링이 기본 방식으로 생성하기가 애매해집니다(리플렉션으로 private 생성자 호출이 가능하긴 하지만 권장되지 않음). 이런 경우도 “팩토리”가 필요합니다.

**FactoryBean 인터페이스**

인터페이스 구성은 다음과 같은 형태입니다.

* `getObject()`: 실제로 스프링 컨테이너에 제공될 오브젝트 생성
* `getObjectType()`: 이 팩토리가 만드는 오브젝트의 타입
* `isSingleton()`: 싱글톤 여부

```kotlin
import org.springframework.beans.factory.FactoryBean

class Message private constructor(private val text: String) {
    fun getText(): String = text

    companion object {
        fun newMessage(text: String): Message = Message(text)
    }
}

class MessageFactoryBean : FactoryBean<Message> {
    var text: String = ""

    override fun getObject(): Message = Message.newMessage(text)

    override fun getObjectType(): Class<*> = Message::class.java

    override fun isSingleton(): Boolean = false
}
```

설정은 일반 빈처럼 `id/class`를 쓰되, 실제로 `message`라는 이름으로 꺼내면 **MessageFactoryBean이 아니라 Message가 나온다**는 점이 핵심입니다.\
그리고 팩토리 빈 자체가 필요하면 `&message`처럼 `&` 접두어로 가져옵니다(책에서도 이 동작을 테스트로 확인합니다).



#### “팩토리 빈을 쓰면 결국 뭐가 달라지나요?”

스프링 입장에서는 “빈 생성 책임”을 팩토리에게 넘기게 됩니다. \
스프링은 `MessageFactoryBean` 자체를 만들고(이건 일반 빈처럼 만들 수 있음), \
그 다음부터는 “진짜 빈 오브젝트(Message)”는 `getObject()`를 호출해서 받습니다.&#x20;

즉, **스프링 빈 생성 전략을 사용자가 교체**할 수 있게 됩니다. \
다이나믹 프록시는 바로 이 지점이 필요합니다. \
프록시 생성은 `new`가 아니라 `Proxy.newProxyInstance(...)`이기 때문입니다.

**다이나믹 프록시를 만드는 TxProxyFactoryBean**

이제 트랜잭션 다이나믹 프록시를 “빈”으로 제공하는 팩토리 빈을 만들 수 있습니다. 핵심 구성 요소는 다음입니다.

* `target`: 타깃 오브젝트 (예: `userServiceImpl`)
* `transactionManager`: 트랜잭션 매니저
* `pattern`: 트랜잭션 적용 메서드 패턴
* `serviceInterface`: 프록시가 구현할 인터페이스(예: `UserService`)

Kotlin 형태로 정리하면 다음과 같습니다.

```kotlin
import org.springframework.beans.factory.FactoryBean
import org.springframework.transaction.PlatformTransactionManager
import java.lang.reflect.Proxy

class TxProxyFactoryBean : FactoryBean<Any> {

    lateinit var target: Any
    lateinit var transactionManager: PlatformTransactionManager
    var pattern: String = ""
    lateinit var serviceInterface: Class<*>

    override fun getObject(): Any {
        val handler = TransactionHandler(
            target = target,
            transactionManager = transactionManager,
            pattern = pattern
        )

        return Proxy.newProxyInstance(
            serviceInterface.classLoader,
            arrayOf(serviceInterface),
            handler
        )
    }

    override fun getObjectType(): Class<*> = serviceInterface

    override fun isSingleton(): Boolean = false
}
```

설정 파일에서는 이제 `userService`를 `UserServiceTx` 같은 클래스가 아니라 `TxProxyFactoryBean`으로 등록하고, 필요한 속성을 주입합니다.



### 6.3.5 프록시 팩토리 빈 방식의 장점과 한계

**장점 1: “프록시 클래스 작성”을 제거한다**

다이나믹 프록시를 쓰면 인터페이스 메서드가 3개에서 30개로 늘어도, 프록시 클래스(정적 구현)를 새로 만들 필요가 없습니다. 호출은 모두 `InvocationHandler.invoke()`로 모이기 때문입니다.

* 정적 프록시: 메서드 수만큼 구현/위임 코드가 늘어남
* 다이나믹 프록시: 메서드 수와 무관하게 invoke 한 곳에서 처리 가능

**장점 2: “프록시 생성 코드”를 스프링 DI로 숨겨 재사용한다**

테스트에서 매번 `Proxy.newProxyInstance(...)`를 직접 호출해 프록시를 만들던 코드를, 팩토리 빈 `getObject()`로 옮기면:

* 애플리케이션 코드/테스트 코드에서 프록시 생성 코드가 사라집니다.
* 설정만 바꿔 여러 타깃에 재사용할 수 있습니다.
* `UserService` 외에 `CoreService` 같은 다른 서비스에도 같은 팩토리를 재사용할 수 있습니다(책에서 coreService 예시로 확장합니다).

**한계 1: 설정(XML) 중복이 다시 커진다**

현실적인 한계는 “부가기능 조합이 많아질수록 설정이 폭발한다”는 점입니다.

* 클래스가 20개, 메서드가 200개인 서비스 계층이 있고
* 트랜잭션뿐 아니라 보안, 로깅, 성능 측정 같은 부가기능을 조합하려고 하면
* 타깃/부가기능 조합만큼 팩토리 빈 정의가 늘어나서, 수백\~수천 라인으로 커질 수 있습니다.
* 설정이 복잡해지면 변경/리뷰/테스트가 어려워집니다.

즉, “코드 중복”을 줄였더니 “설정 중복”이 커지는 형태입니다.

**한계 2: TransactionHandler 같은 부가기능 객체가 계속 늘어난다**

문제 제기는 이 부분입니다.

* `TransactionHandler`는 타깃을 프로퍼티로 갖습니다.
* 타깃이 바뀌면 결국 handler도 새로 필요해질 수 있습니다.
* handler를 프록시 팩토리 빈 내부에서 매번 생성하면, 싱글톤처럼 공유하기도 애매합니다(타깃이 다르므로).
* 결국 “모든 타깃에 적용 가능한 단일 handler” 같은 방향을 고민하게 만듭니다.

이 한계들이 다음 단계(스프링 AOP, 어드바이스/포인트컷/어드바이저로 일반화)로 넘어가야 하는 이유를 자연스럽게 만듭니다.

#### “지금 구조에서 ‘설정 중복’과 ‘핸들러 중복’을 동시에 없애려면 무엇이 더 필요할까?”

답은 “설정으로 매번 타깃/패턴을 나열하지 않고, **공통 규칙을 선언**할 수 있어야 한다”. \
예를 들어 “서비스 계층의 특정 패키지 하위 public 메서드 전체”처럼 더 일반화된 규칙이 필요합니다. \
그리고 “트랜잭션 부가기능” 자체도 특정 타깃에 묶이지 않고, 적용 규칙과 결합되어 재사용 가능한 형태여야 합니다. \
이 요구사항이 바로 스프링 AOP의 포인트컷/어드바이스 모델로 연결됩니다.



## 6.4. 스프링의 프록시 팩토리 빈

6.4에서는 스프링이 제공하는 `ProxyFactoryBean`을 사용하여 다음과 같이 구조를 재설계합니다.

* 부가기능은 **Advice**로 분리
* 적용 대상 메서드 선정은 **Pointcut**으로 분리
* 둘을 묶은 **Advisor** 개념 도입
* 프록시 생성은 `ProxyFactoryBean`이 담당
* 모든 요소를 DI로 조합

6.4는 “다이나믹 프록시를 사용하는 기술”을 넘어서, **부가기능을 구조적으로 분리하고 재사용 가능한 형태로 만드는 설계합니다.**

### 6.4.1 ProxyFactoryBean

**기존 방식의 한계**

6.3의 `TxProxyFactoryBean` 구조를 다시 정리해 보면 다음과 같습니다.

```kotlin
package springbook.user.service

import org.springframework.transaction.PlatformTransactionManager
import org.springframework.transaction.TransactionStatus
import org.springframework.transaction.support.DefaultTransactionDefinition
import java.lang.reflect.InvocationHandler
import java.lang.reflect.InvocationTargetException
import java.lang.reflect.Method

class TransactionHandler : InvocationHandler {

    lateinit var target: Any
    lateinit var transactionManager: PlatformTransactionManager
    var pattern: String = ""

    override fun invoke(
        proxy: Any,
        method: Method,
        args: Array<out Any>?
    ): Any? {

        // 트랜잭션 적용 대상 메서드가 아니면 바로 위임
        if (!method.name.startsWith(pattern)) {
            return if (args == null) {
                method.invoke(target)
            } else {
                method.invoke(target, *args)
            }
        }
        
        // 트랜잭션 처리 로직을 수행~
        val status: TransactionStatus =
            transactionManager.getTransaction(DefaultTransactionDefinition())

        return try {
            val ret = if (args == null) {
                method.invoke(target)
            } else {
                method.invoke(target, *args)
            }

            transactionManager.commit(status)
            ret

        } catch (e: InvocationTargetException) {
            transactionManager.rollback(status)
            throw e.targetException
        }
        // ~트랜잭션 처리 로직을 수행
    }
}
```

```kotlin
package springbook.user.service

import org.springframework.beans.factory.FactoryBean
import java.lang.reflect.Proxy

class TxProxyFactoryBean : FactoryBean<Any> {

    lateinit var target: Any // 타깃 객체를 직접 보유
    lateinit var transactionManager: PlatformTransactionManager
    var pattern: String = ""
    lateinit var serviceInterface: Class<*>

    override fun getObject(): Any {

        val handler = TransactionHandler().apply {
            this.target = this@TxProxyFactoryBean.target
            this.transactionManager = this@TxProxyFactoryBean.transactionManager
            this.pattern = this@TxProxyFactoryBean.pattern
        }

        return Proxy.newProxyInstance(
            serviceInterface.classLoader,
            arrayOf(serviceInterface),
            handler
        )
    }

    override fun getObjectType(): Class<*> {
        return serviceInterface
    }

    override fun isSingleton(): Boolean {
        return false
    }
}
```

* `InvocationHandler`가
  * 타깃 객체를 직접 보유
  * 트랜잭션 처리 로직을 수행
  * 메서드 이름 패턴으로 적용 대상 선정
* 타깃이 바뀌면 핸들러도 새로 필요
* 메서드 선정 로직을 바꾸려면 핸들러 코드 수정 필요

이 구조는 부가기능과 적용 대상 선정이 강하게 결합된 상태입니다.

\
트랜잭션 로직은 재사용하고 싶지만, 적용 대상 메서드 패턴은 서비스마다 다를 수 있습니다. 그렇다면 이 두 책임을 한 객체가 모두 가져야 할까요?

**ProxyFactoryBean의 등장**

`ProxyFactoryBean`은 스프링이 제공하는 프록시 생성 전용 팩토리 빈입니다.

차이점은 다음과 같습니다.

1. JDK 다이나믹 프록시를 직접 다루지 않습니다.
2. `InvocationHandler` 대신 `MethodInterceptor`를 사용합니다.
3. 여러 개의 부가기능을 하나의 프록시에 적용할 수 있습니다.
4. 메서드 선정 로직을 외부 객체로 분리할 수 있습니다.

**MethodInterceptor 도입**

기존 JDK 방식:

```kotlin
import java.lang.reflect.InvocationHandler
import java.lang.reflect.Method

class UppercaseHandler(private val target: Any) : InvocationHandler {
    override fun invoke(proxy: Any, method: Method, args: Array<out Any>?): Any? {
        val result = if (args == null) method.invoke(target)
        else method.invoke(target, *args)
        return (result as String).uppercase()
    }
}
```

문제는 다음과 같습니다.

* 타깃을 직접 알고 있어야 함
* 메서드 선택 로직까지 포함해야 함
* 재사용성이 떨어짐

스프링 방식:

```kotlin
import org.aopalliance.intercept.MethodInterceptor
import org.aopalliance.intercept.MethodInvocation

class UppercaseAdvice : MethodInterceptor {

    override fun invoke(invocation: MethodInvocation): Any? {
        val result = invocation.proceed()
        return (result as String).uppercase()
    }
}
```

차이점:

* 타깃을 직접 호출하지 않습니다.
* `MethodInvocation`이 타깃 호출을 담당합니다.
* Advice는 순수하게 부가기능에만 집중합니다.

이 구조는 템플릿/콜백 패턴입니다.

* ProxyFactoryBean이 템플릿
* MethodInterceptor가 콜백

**ProxyFactoryBean 사용 예제**

```kotlin
import org.springframework.aop.framework.ProxyFactoryBean

val pfBean = ProxyFactoryBean()
pfBean.setTarget(HelloTarget())
pfBean.addAdvice(UppercaseAdvice())

val proxiedHello = pfBean.getObject() as Hello
```

구조는 다음과 같습니다.

클라이언트\
→ 프록시\
→ MethodInterceptor\
→ 타깃

***

**포인트컷 도입**

6.3에서는 메서드 이름 패턴을 `TransactionHandler` 안에서 비교했습니다.

이제 이를 Pointcut으로 분리합니다.

```kotlin
import org.springframework.aop.support.NameMatchMethodPointcut

val pointcut = NameMatchMethodPointcut()
pointcut.setMappedName("sayH*")
```

이렇게 하면 sayH로 시작하는 메서드만 부가기능이 적용됩니다.

***

**Advisor: Advice + Pointcut**

스프링은 Advice와 Pointcut을 묶어 Advisor로 관리합니다.

```kotlin
import org.springframework.aop.support.DefaultPointcutAdvisor

val advisor = DefaultPointcutAdvisor(pointcut, UppercaseAdvice())
pfBean.addAdvisor(advisor)
```

구조:

프록시\
→ Advisor\
→ Pointcut\
→ Advice\
→ 타깃

이제 부가기능과 메서드 선정이 완전히 분리되었습니다.

***

#### 6.4.2 ProxyFactoryBean 적용

이제 트랜잭션 로직을 MethodInterceptor로 변환합니다.

```kotlin
import org.aopalliance.intercept.MethodInterceptor
import org.aopalliance.intercept.MethodInvocation
import org.springframework.transaction.PlatformTransactionManager
import org.springframework.transaction.support.DefaultTransactionDefinition

class TransactionAdvice(
    private val transactionManager: PlatformTransactionManager
) : MethodInterceptor {

    override fun invoke(invocation: MethodInvocation): Any? {

        val status = transactionManager
            .getTransaction(DefaultTransactionDefinition())

        return try {
            val ret = invocation.proceed()
            transactionManager.commit(status)
            ret
        } catch (e: RuntimeException) {
            transactionManager.rollback(status)
            throw e
        }
    }
}
```

중요한 차이점:

* `InvocationTargetException` 처리 필요 없음
* 타깃 호출은 `proceed()`가 담당
* 타깃에 직접 의존하지 않음

***

**XML 설정**

```xml
<bean id="transactionAdvice"
      class="springbook.user.service.TransactionAdvice">
    <property name="transactionManager"
              ref="transactionManager"/>
</bean>

<bean id="transactionPointcut"
      class="org.springframework.aop.support.NameMatchMethodPointcut">
    <property name="mappedName"
              value="upgrade*"/>
</bean>

<bean id="transactionAdvisor"
      class="org.springframework.aop.support.DefaultPointcutAdvisor">
    <property name="advice"
              ref="transactionAdvice"/>
    <property name="pointcut"
              ref="transactionPointcut"/>
</bean>

<bean id="userService"
      class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target"
              ref="userServiceImpl"/>
    <property name="interceptorNames">
        <list>
            <value>transactionAdvisor</value>
        </list>
    </property>
</bean>
```

***

**재사용 구조**

TransactionAdvice는 싱글톤으로 등록 가능합니다.

여러 서비스에 동일하게 적용 가능합니다.

* UserService
* OrderService
* PaymentService

모두 동일 Advice + 다른 Pointcut 조합으로 확장 가능합니다.

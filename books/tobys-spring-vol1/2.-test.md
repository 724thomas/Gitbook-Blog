---
description: 테스트
---

# 2. Test

## 2.1. UserDaoTest 다시 보기

UserDaoTest는 DAO가 의도한 대로 정확히 동작하는지를 직접 실행을 통해 빠르게 검증하기 위한 초기 테스트 코드입니다. main() 메서드를 이용해 UserDao의 add(), get() 기능을 수행하고 결과를 콘솔로 확인하는 방식으로 작성되었습니다.

이 테스트는 자동화 수준은 낮지만 DAO 개발 초기에 기능 검증과 리팩터링 안정성을 확보하는 데 중요한 역할을 하게됩니다.



### 2.1.1. 테스트의 유용성

초기 UserDao 테스트는 아래와 같은 방식으로 진행됩니다.

* main() 메서드를 이용해 테스트 생성
* 스프링 컨테이너에서 UserDao 빈을 가져옴
* User 객체를 생성해서 add() 호출
* 다시 get()으로 조회해 결과를 콘솔로 출력.

이 과정을 반복 실행하면서 기능이 정상 동작함을 확인했습니다.



### 2.1.2. UserDaoTest의 특징

특징은 아래와 같습니다.

* 자바에서 가장 간단히 실행 가능한 `main()` 메서드를 사용
* 테스트 대상인 UserDao를 직접 호출
* 테스트에 필요한 User 객체를 코드로 직접 생성
* 테스트 결과를 콘솔 출력으로 확인
* 각 단계가 문제없이 끝나면 성공 메시지를 출력

가장 눈에 띄는 특징은 테스트 실행과 검증이 전적으로 개발자의 눈에 의존한다는 점입니다.

#### 웹을 통한 DAO 테스트 방법의 문제점

실무에서는 DAO를 테스트하기 위해 웹 화면을 띄우고\
폼에 값을 입력한 뒤 버튼을 눌러 결과를 확인하는 경우가 많습니다.

이 방식은 다음과 같은 심각한 문제를 가집니다.

* DAO 테스트를 위해 서비스, 컨트롤러, JSP까지 모두 필요
* 어느 계층에서 오류가 발생했는지 파악하기 어려움
* DB 문제인지, SQL 문제인지, MVC 설정 문제인지 구분이 힘듦
* 테스트 실패 시 원인 분석에 많은 시간 소요
* 서버 설정, 파라미터 전달, 화면 로직까지 테스트에 영향

결국 **정말 확인하고 싶은 것은 UserDao인데**, 다른 계층의 코드와 환경이 테스트를 방해하게 됩니다.



#### 작은 단위의 테스트

테스트 대상이 명확하다면, 가능한 한 **그 대상만 집중해서 테스트**하는 것이 바람직합니다.\
이를 위해서는 테스트 단위를 최대한 작게 가져가야 합니다.

UserDaoTest의 경우 다음과 같은 특징을 가집니다.

* 웹 서버 불필요
* MVC, 서비스 계층 불필요
* IDE 또는 콘솔에서 즉시 실행 가능
* 오류 발생 시 UserDao 또는 DB 접근 로직으로 원인 범위가 좁혀짐

이처럼 작은 단위로 코드의 동작을 검증하는 테스트를 단위 테스트(Unit Test)라고 합니다.\
여기서 단위란 클래스 하나일 수도 있고, 메서드 하나일 수도 있으며 **관심사를 집중해서 검증 가능한 최소 범위**를 의미합니다.



#### 자동수행 테스트 코드

UserDaoTest의 또 다른 중요한 특징은 **테스트 데이터 준비와 실행이 모두 코드로 자동화**되어 있다는 점입니다.

* 매번 화면에서 값을 입력할 필요 없음
* DB에 값을 넣고 조회하는 과정이 자동 수행
* 실행 시간 짧음
* 반복 실행 부담 없음

이러한 테스트는 다음과 같은 장점을 제공합니다.

* 코드 수정 후 즉시 전체 테스트 실행 가능
* 리팩터링 시 기존 기능이 깨지지 않았음을 빠르게 확인 가능
* 테스트 실행 자체가 개발 속도를 늦추지 않음



#### 지속적인 개선과 점진적인 개발을 위한 테스트

초기 DAO 구현 단계에서는 설계가 완벽하지 않아도 괜찮습니다.\
중요한 것은 **작동하는 최소한의 코드 + 이를 검증하는 테스트**를 먼저 만드는 것입니다.

테스트가 있다면 다음이 가능해집니다.

* 구조 개선 시 기능 유지 여부 즉시 확인
* 설계 변경에 대한 심리적 부담 감소
* 작은 변경을 반복하며 코드 품질 향상

만약 테스트 없이 스프링 설정, DI, 구조 설계를 한 번에 모두 적용했다면 오류 발생 시 원인을 찾는 데 훨씬 많은 시간이 들었을 것입니다.



### 2.1.3. UserDaoTest의 문제점

UserDaoTest는 분명 장점이 있지만, 한계도 존재합니다.

**■ 수동 확인 작업의 번거로움**

* 테스트 결과를 사람이 직접 콘솔 출력으로 확인해야 함
* 기대값과 실제값 비교를 코드가 해주지 않음
* 작은 실수도 놓칠 가능성 존재

**■ 실행 작업의 번거로움**

* 테스트 클래스가 많아질수록 `main()` 실행이 반복됨
* 테스트 결과를 체계적으로 관리하기 어려움
* 성공/실패 이력을 자동으로 기록하지 못함

결국 `main()` 메서드 기반 테스트는\
**초기 검증에는 유용하지만, 체계적인 테스트 방법으로는 한계**가 있습니다.





## 2.2. UserDaoTest 개선

2.1. 에서 만든 UserDaoTest는 DAO 기능을 빠르게 검증하지만, 결과를 직접 확인해야하는 불편함이 있었고, 반복 실행과 관리가 어려웠습니다.

* 이제는 테스트 결과 검증을 코드가 하도록 개선하고,
* main() 기반 테스트를 JUnit 테스트로 전환해 효율적으로 실행 및 관리하게 됩니다.



### 2.2.1. 테스트 검증의 자동화

기존 UserDaoTest의 가장 큰 문제는 테스트 성공 여부를 사람이 확인하는 것입니다.

콘솔 출력에 의지하는 것은 휴먼에러가 발생할 수도 있고, 반복에 적합하지도 않습니다.

#### 테스트 결과의 종류

테스트 결과는 다음 세 가지로 나뉩니다.

* 테스트 에러\
  테스트 수행 중 예외가 발생해 정상적으로 끝나지 않은 경우
* 테스트 실패\
  에러는 없지만 결과가 기대와 다른 경우
* 테스트 성공\
  에러도 없고 결과도 기대와 일치하는 경우

기존 테스트 코드는 에러만 확인 가능했고,\
**성공과 실패를 코드 차원에서 구분하지 못했습니다.**

#### 검증 로직 추가

기존에는 `get()` 결과를 단순 출력만 했습니다.

```kotlin
println(user2.name)
println(user2.password)
println("${user2.id} 조회 성공")
```

이를 **기대값과 실제값을 비교하는 코드**로 변경합니다.

```kotlin
if (user.name != user2.name) {
    println("테스트 실패 (name)")
} else if (user.password != user2.password) {
    println("테스트 실패 (password)")
} else {
    println("조회 테스트 성공")
}
```

이제 테스트 코드는 다음을 보장합니다.

* `add()`로 저장한 값이
* `get()`으로 정확히 조회되는지
* 필드 단위로 자동 검증

이 검증은 `get()`뿐 아니라 **`add()`의 정상 동작까지 함께 검증**합니다.\
만약 `add()`가 실패했다면 `get()` 검증도 통과할 수 없습니다.

#### 자동 테스트의 의미

이제 테스트는 다음 과정을 모두 자동으로 수행합니다.

* 테스트 실행
* 테스트 대상 코드 호출
* 기대값과 결과 비교
* 성공 / 실패 판단

개발자가 할 일은 **마지막 출력이 “테스트 성공”인지 확인하는 것뿐**입니다.\
이 단계에서 UserDao는 **언제든지 반복 실행 가능한 자동 테스트 대상**이 됩니다.



### 2.2.2. 테스트의 효율적인 수행과 결과 관리

main() 기반 테스트는 자동 검증까지는 가능해졌지만,\
여전히 다음과 같은 문제가 남아 있습니다.

* 테스트가 많아질수록 실행이 번거로움
* 테스트 결과를 한눈에 파악하기 어려움
* 테스트 실패 원인을 체계적으로 알기 어려움

이 문제를 해결하기 위해 **테스트 전용 프레임워크**가 필요합니다.

#### JUnit 테스트로의 전환

JUnit은 자바 진영에서 가장 널리 사용되는 **단위 테스트 프레임워크**입니다.\
JUnit을 사용하면 다음이 가능해집니다.

* 테스트 실행 자동화
* 테스트 성공 / 실패 자동 판별
* 실패 위치와 원인 명확한 출력
* IDE, 빌드 도구와 자연스럽게 연동

#### 테스트 메서드 전환

기존 `main()` 메서드 테스트는 JUnit에 적합하지 않습니다. 따라서 테스트 코드를 **일반 메서드로 옮기고 `@Test`를 붙입니다.**

**Kotlin + JUnit 테스트 메서드 예시**

```kotlin
import org.junit.Test
import org.springframework.context.support.GenericXmlApplicationContext
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.MatcherAssert.assertThat

class UserDaoTest {

    @Test
    fun addAndGet() {
        val context = GenericXmlApplicationContext("applicationContext.xml")
        val dao = context.getBean("userDao", UserDao::class.java)

        val user = User().apply {
            id = "gyumee"
            name = "박성철"
            password = "springno1"
        }

        dao.add(user)
        val user2 = dao.get(user.id)

        assertThat(user2.name, `is`(user.name))
        assertThat(user2.password, `is`(user.password))
    }
}
```

***

#### _검증 코드의 변화_

기존 if/else 검증은 다음과 같이 바뀝니다.

```kotlin
assertThat(user2.name, `is`(user.name))
assertThat(user2.password, `is`(user.password))
```

* 조건이 맞지 않으면 `AssertionError` 발생
* 예외가 발생하지 않으면 테스트 성공
* 성공 메시지를 출력할 필요 없음

JUnit은 테스트 결과를 **프레임워크 차원에서 관리**합니다.

#### JUnit 테스트 실행

JUnit 테스트는 IDE, 빌드 도구, 또는 코드로 실행할 수 있습니다.

```kotlin
import org.junit.runner.JUnitCore

fun main() {
    JUnitCore.main("springbook.user.dao.UserDaoTest")
}
```

실행 결과 예시:

```
JUnit version 4.7
Time: 0.578
OK (1 test)
```

실패 시에는 다음 정보가 자동 출력됩니다.

* 실패한 테스트 메서드
* 기대값과 실제값
* 실패 지점의 코드 위치
* 호출 스택

이는 **main() 테스트로는 얻기 어려운 수준의 피드백**입니다.

***

#### _JUnit 테스트의 의미_

JUnit을 적용한 UserDaoTest는 이제 다음을 만족합니다.

* 테스트 결과 자동 판별
* 반복 실행 부담 없음
* 코드 변경 후 즉시 검증 가능
* 실패 원인 즉시 파악 가능

이로써 UserDao는 **안전하게 리팩터링할 수 있는 코드**가 됩니다.\
앞으로 구조를 변경하거나 기술을 교체하더라도,\
이 테스트를 통과한다면 기능은 여전히 정상이라는 확신을 가질 수 있습니다.

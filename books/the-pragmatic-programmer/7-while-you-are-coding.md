---
description: 코딩하는 동안
---

# #7 While You Are Coding

## Topic 37. 파충류의 뇌에 귀 기울이기

#### 요약

이 항목은 프로그래머가 업무 중 느끼는 불안·초조·의심 같은 감정이 단순한 감정이 아니라 **파충류의 뇌(lizard brain)** 가 보내는 경고 신호라는 점에 주목합니다. 이러한 감정은 문제를 조기에 감지하고, 설계를 개선하고, 작업 방향을 수정하는 데 중요한 역할을 합니다. 핵심은 이 신호를 억누르지 말고, **외부화·관찰·실험·프로토타이핑**을 통해 실제 행동으로 전환하는 것입니다.

***

#### 파충류의 뇌란 무엇인가a

게빈 드 베커는 사람들이 자신의 안전을 지킬 수 있는 **본능적 감각을 무시하도록 사회적으로 학습돼 왔다**고 설명합니다. 프로그래머 역시 일상적으로 이러한 신호를 받지만, “감정적이다”, “불필요하다”는 이유로 무시할 때가 많습니다.

파충류의 뇌는 아래와 같은 형태로 반응합니다.

* 원인을 설명하기 어려운 불편함
* 코드나 설계에서 느껴지는 이상한 감각
* 새로운 프로젝트에서 느껴지는 막연한 두려움
* 대화 중 뭔가 맞지 않는 느낌

이러한 반응은 대부분 **정확한 위험 감지 신호**입니다.

***

#### 개발자가 느끼는 불안의 원인

#### _**파충류의 뇌가 주는 직관적 의심**_

경험이 쌓일수록 우리는 코드나 설계에서 “이상하다”는 느낌을 더 자주 받습니다. 그 이유를 나중에서야 깨닫는 경우도 많습니다.

#### _**합리적 두려움**_

새로운 프로젝트, 리팩토링, 난해한 버그는 누구에게나 두려움을 줍니다. 이는 실력이 부족해서 오는 감정이 아니라, 과거의 경험을 통해 형성된 **학습된 경계심**입니다.

#### _**가면 증후군**_

개발자가 흔히 겪는 “내가 이 일을 해도 되는가?”라는 감정 역시 자연스러운 현상입니다. 프로젝트가 복잡할수록 파충류의 뇌는 경고를 더 크게 보냅니다.

***

#### 본능적 감정과 싸우는 법

#### _**일단 멈춰서 관찰하기**_

막연한 불안이 생겼다면 잠시 손을 멈추고

* 자리 이동
* 산책
* 커피 한 잔
* 화면에서 눈 떼기\
  와 같은 방식으로 뇌에 정리할 시간을 주는 것이 좋습니다.

#### _**불안을 외부화하기**_

머릿속에서만 고민하면 불편함은 더 커집니다. 아래와 같이 외부로 꺼내는 것이 효과적입니다.

* 그림 그리기
* 말로 설명하기
* 개발자가 아닌 사람에게 설명한다고 가정하기
* 포스트잇으로 정리하기

설명 과정에서 **문제가 무엇인지 구조적으로 드러납니다.**

***

#### 프로토타이핑의 힘

#### _**놀이처럼 접근하기**_

엔디 와이어는 프로그래머들이 에디터 앞에서만 문제를 해결하려 하면 비효율적이라고 말합니다. 눈앞에서 코드를 붙잡기보다

* 적어보기
* 그려보기
* 가볍게 실험해보기\
  가 훨씬 빠를 때가 많습니다.

#### _**프로토타입을 만드는 절차**_

1. 포스트잇에 “프로토타이핑 중”이라고 적어 책상 옆에 붙인다.
2. 실패를 가정하고 작게 실험한다.
3. 실험하면서 배운 점을 문장으로 정리한다.
4. 정리한 내용을 기반으로 코드를 다시 작성한다.

#### _**이 방법이 효과적인 이유**_

* 두려움을 줄인다.
* 복잡성을 작은 조각으로 나눈다.
* 설계를 가볍게 검증할 수 있다.
* 모호한 감정을 구체적 행동으로 바꾼다.

***

#### 여러분의 코드만의 문제가 아니다

우리 업무 대부분은 **기존 코드 읽기**입니다.\
다른 개발자가 작성한 코드가 이상하고 불편하게 느껴지는 것은 자연스러운 일이며,\
그 불편함은 **리팩토링이 필요하다는 신호**일 뿐입니다.\
자책할 필요가 없습니다.

***

#### 파충류의 뇌에 귀 기울이는 실천적 방법

#### _**잠시 멈추기**_

불안하거나 찜찜한 감정이 들면 즉시 멈추고 상황을 관찰한다.

#### _**문제를 외부화하기**_

그림, 설명, 포스트잇, 메모 등으로 생각을 밖으로 끌어낸다.

#### _**불편한 감정을 가볍게 해석하지 않기**_

감정은 실력 부족의 증거가 아니라 **신호**다.

#### _**불안의 이유를 문장으로 표현하기**_

예시:

* “이 함수는 책임이 너무 많다.”
* “이 API는 예외 상황을 설명하지 않는다.”
* “이 설계는 확장성을 고려하지 않았다.”

문장으로 정리하면 해결 방향이 보입니다.

***

#### Kotlin 실무 관점의 활용 팁

#### _**불안한 영역을 샌드박스로 분리해 실험하기**_

```kotlin
// 1. 프로토타이핑용 임시 모델
data class DraftUser(
    val id: Long,
    val nickname: String?,
    val age: Int?,
)

// 2. 불확실한 부분만 점검하는 임시 함수
fun validateDraft(user: DraftUser): List<String> {
    val issues = mutableListOf<String>()

    if (user.nickname.isNullOrBlank()) {
        issues += "닉네임이 비어 있습니다."
    }
    if ((user.age ?: 0) < 0) {
        issues += "나이가 유효하지 않습니다."
    }

    return issues
}

// 3. 실험 과정에서 드러난 내용을 정식 코드에 반영
```

이 방식은 본 코드에 손대기 전,\
**불안 요소를 안전하게 탐색**하고 문제의 구조를 명확히 파악하는 데 도움이 됩니다.

***

#### 도전해 볼 것

* 미뤄두고 있던 일 중 **약간 무섭고 어렵게 느껴지는 것**을 하나 고른다.
* 시간을 1\~2시간으로 제한하고 이번 항목의 기법을 적용한다.
* 프로토타입 방식으로 가볍게 실험한다.
* 타이머가 울리면 결과물을 지워도 좋다.
* 중요한 것은 **시작했고, 배웠다는 사실**이다.









## Topic 38. 우연에 맡기는 프로그래밍

#### 요약

이 항목은 프로그래밍 과정에서 우리가 얼마나 자주 **우연에 의존해 성공했다고 착각하는지**를 지적합니다. 전쟁터에서 지뢰밭을 건너는 병사의 비유처럼, 우리는 코드가 “운 좋게” 작동한 것을 실력으로 오해하고, 이를 기반으로 의사결정을 반복하곤 합니다.\
핵심 메시지는 명확합니다.\
개발자는 **우연에 맡기는 프로그래밍을 멈추고, 의도적으로 프로그래밍해야 한다**는 것입니다.

***

#### 지뢰밭을 통과한 병사의 비유

한 병사가 지뢰밭을 지나 아무 일도 없었다고 해서 그 길에 지뢰가 없었다는 뜻은 아닙니다.\
그 병사는 단지 **운이 좋았을 뿐**, 그 경험으로 확신을 가지면 다음에는 큰 위험으로 이어질 수 있습니다.

프로그래머도 마찬가지입니다.\
코드가 “돌아갔다”고 해서 그것이 **맞는 코드, 올바른 설계, 안전한 구조**라는 의미는 아닙니다.

그래서 우리는

* 우연히 성공한 코드
* 이유를 모르는 결과
* 명확히 설명되지 않는 동작\
  을 경계해야 합니다.

***

#### 우연에 맡기는 프로그래밍의 사례

#### _프레드가 겪는 코드 문제_

프레드는 프로그래밍을 하다 보면 어느 날 갑자기 문제가 해결되거나,\
“이제 되는 것 같다”는 느낌을 받습니다.\
하지만 그 이유를 설명하지 못한 채 넘어간다면, 그것은 실력이 아니라 **운의 결과**입니다.

프레드가 코드를 작성할 때 반복되는 패턴은 다음과 같습니다.

* 조금 수정한다.
* 실행해본다.
* 잘 되는 것 같다.
* 돌아가는 것 같으니 넘어간다.

하지만 코드가 망가지는 이유를 모른다면 해결은 근본적일 수 없습니다.

***

#### 구현 과정에서 생기는 우연

#### _잘못된 입력과 잘못된 반응_

예를 들어 잘못된 데이터를 던졌을 때 프로그램이 문제 없이 실행되는 경우가 있습니다.\
이는 실제로 “문제 없다”가 아니라, **우연히 예외 상황이 드러나지 않았을 뿐**입니다.

이런 우연이 반복되면 개발자는 잘못된 확신을 가지게 되고,\
나중에 환경이 변하면 같은 루틴이 더 이상 작동하지 않게 됩니다.

***

#### GUI 관련 우연과 잘못된 호출

프레드가 GUI 렌더링 코드를 작성하면서 다음과 같이 호출한다고 가정합니다.

```
paint();
invalidate();
validate();
revalidate();
repaint();
paintImmediately();
```

프레드는 무엇인가를 고치려는 마음으로 여러 호출을 섞어 사용하지만,\
실제로는 **프레임워크가 의도한 방식과 전혀 다르게 호출**한 것입니다.\
지금 화면이 우연히 그려졌다고 해서 올바른 호출 순서라는 의미는 아닙니다.

이러한 우연들이 쌓이면 문제는 더욱 복잡해집니다.

* 화면이 이상하게 보임
* 일부 시스템에서는 정상, 다른 시스템에서는 오류
* 환경 차이로 동작 변경
* CPU 사용량 증가
* 버그 추적 불가

***

#### 비슷하다고 괜찮은 게 아니다

프로젝트에서 외부 장치의 데이터 수집 타이밍이 우연히 잘 맞아 보였다고 해서,\
그것이 정확한 설계라는 뜻은 아닙니다.

프레드는 데이터를 받아들이는 타이밍이 “대체로 맞아 보이니 괜찮다”고 생각했지만,\
실제로는 설계 자체가 부정확했습니다.\
결국 프로젝트는 폐기되었습니다.

***

#### 상관관계와 유럽 패턴

인간은 인지적으로 **패턴과 연관성**을 찾고 싶어 합니다.\
그래서 우연한 결과를 원인으로 착각하는 오류를 범하곤 합니다.

예를 들어 러시아에서 머리카락이 많은 사람이 대통령이 된다는 우스갯소리가 있다고 가정하면,\
이는 **상관관계가 인과관계로 오해된** 사례입니다.

코드에서도 같은 착각을 하기 쉽습니다.

* 특정 버전에서만 나는 오류
* 특정 조건에서만 작동하는 기능
* 새로운 환경에서 나타나는 비정상 동작

이를 모두 우연으로 치부하면 더 큰 문제를 낳습니다.

***

#### 상황에서 생기는 우연

예를 들어 특정 OS에서는 화면에 글자가 잘 보이는 GUI 코드가\
다른 환경에서는 흐릿하게 보일 수 있습니다.

프레드는 이를 “환경이 다르니까 어쩔 수 없다”고 받아들이지만,\
실제로는

* DPI 설정
* 렌더러 차이
* 서버의 파일 접근 방식 차이\
  등이 원인일 수 있습니다.

문제를 명확히 파악하지 않으면,\
작동하는 것처럼 보이는 코드에 우연히 의존하게 됩니다.

***

#### 의도적으로 프로그래밍하기

“돌아가니까 괜찮다”는 태도는 위험합니다.\
개발자는 다음을 항상 고려해야 합니다.

#### _정확한 원인 파악_

왜 이 코드가 작동하는가?\
지금의 동작이 정말 의도된 결과인가?

#### _이해하지 못한 기술에 기대지 않기_

알지 못하는 기술 위에서 가정을 세우는 것은 위험합니다.\
우연한 동작은 언제든 신뢰를 무너뜨립니다.

#### _계획을 세우고 기록하기_

계획 없이 코드를 작성하면\
수정, 테스트, 배포 과정에서 우연의 영향을 크게 받습니다.

#### _코드를 시험하고 결과를 기록하기_

테스트를 통해 확인된 사실과 가정을 분리해야 합니다.\
테스트 결과가 맞다면 왜 맞는지, 틀렸다면 왜 틀렸는지 기록하는 것이 중요합니다.

***

#### 우선순위와 비용

가정이 틀렸음에도 코드가 우연히 돌아가면\
나중에 훨씬 큰 비용이 발생할 수 있습니다.

* 변경 비용 증가
* 일정 지연
* QA 비용 증가
* 버그 유출
* 설계 전체의 붕괴

따라서 “왜 되는지” 또는 “왜 안 되는지”를 분석하는 데 시간을 투자해야 합니다.


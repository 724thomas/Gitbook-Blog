---
description: 동시성
---

# #6 Concurrency

## 📌 시간적 결합(Temporal Coupling)을 깨뜨린다는 것

**— 일하는 순서에 끌려 다니지 않는 소프트웨어를 만들기 위해**

소프트웨어 아키텍처에서 “시간”이라는 요소는 생각보다 훨씬 중요한 문제다.\
우리가 평소에 느끼는 시간은 “일정” 같은 단기적인 것들이지만,\
사실 진짜 중요한 시간은 **설계된 시스템 안에서 작업들이 서로 어떤 ‘순서’에 의존하는가**이다.

많은 개발팀이 기능을 구현할 때 이런 식으로 생각하곤 한다.

> “이 작업 하고 → 그다음에 이것 하고 → 다음에 저것 한다.”

겉보기에는 자연스러워 보이지만, 이렇게 사고하면\
소프트웨어는 **시간적 결합(Temporal Coupling)** 이라는 함정에 빠지게 된다.

즉,\
**A가 끝나야 B를 할 수 있고,**\
**B가 끝나야 C를 할 수 있는** 식으로\
모든 작업이 ‘순차 실행’을 강요하게 되는 것이다.

그러나 실제 세상에서는 여러 일이 동시에 벌어지고,\
사용자는 언제든 버튼을 클릭할 수 있고,\
보고서는 한 번에 도착하지 않으며,\
에러는 예상치 못한 순간에 발생한다.

이런 현실을 반영하지 않고 순차적으로만 생각하면\
시스템은 점점 유연성을 잃고,\
버그는 증가하며,\
변경 비용은 커진다.

***

🔎 동시성을 먼저 보라

책에서는 이렇게 말한다.

> “메시지는 언제나 반드시 ‘보낸 순서’보다 먼저 도착할 수 있다.”

실제로 네트워크나 운영 환경에서는 이런 일이 흔하다.\
따라서 우리는 **‘순차적이어야 하는 것’과 ‘동시에 일어나도 되는 것’을 구분해야 한다.**

많은 프로젝트에서는 이 구분을 거의 하지 않고,\
그냥 “일어나는 순서대로” 코드를 짜버린다.

그래서 나중에 이렇게 된다.

* 왜 버튼을 클릭하면 UI가 멈출까?
* 왜 갑자기 데이터가 꼬이지?
* 왜 이벤트가 순서대로 처리되지 않는 거야?
* 왜 하나 고치면 다른 데서 또 터지는 거지?

답은 대부분 **시간적 결합** 때문이다.

***

🧠 동시성을 찾는 방법

책이 제안하는 방법은 의외로 단순하다.

#### 📌 1. “무조건 순서가 필요한 작업”과

#### 📌 2. “동시에 일어나도 되는 작업”을 구분하라.

이때 유용한 도구가 UML의 **활동 다이어그램(Activity Diagram)** 이다.\
특히 **동기화 막대(Synchronization Bar)** 를 활용하면\
동시에 시작하거나 동시에 끝나야 하는 작업들을 명확히 구분할 수 있다.

***

🍹 예제: 피냐 콜라다 만들기

책에서는 피냐 콜라다 칵테일 제조를 예로 든다.\
보통 우리는 레시피를 이렇게 “순서대로” 읽는다.

1. 믹서를 연다
2. 파인애플 믹스를 붓는다
3. 코코넛 밀크를 넣는다
4. 화이트 럼을 넣는다
5. 얼음을 넣는다
6. 뚜껑을 닫는다
7. 갈아준다
8. 잔을 가져온다
9. 우산 장식을 가져온다
10. 따르고 마무리한다

겉으로 보면 모든 것이 순차적으로 보이지만,\
냉정히 따져보면 동시에 할 수 있는 작업도 많다.

예를 들어:

* “잔 가져오기(8)”는\
  믹싱하는 동안(7) **동시에** 해도 된다.
* “우산 장식 가져오기(9)”도 믹싱 도중에 하고 있어도 된다.

그래서 활동 다이어그램으로 다시 그리면\
동시에 실행될 수 있는 작업 흐름이 눈에 보인다.

→ 이는 소프트웨어에서도 동일하다.\
순서에 종속된 작업만 “순차”로 두고,\
나머지는 “동시 실행 가능”하게 만들어야 한다.

***

🏎 왜 이게 중요한가?

시간적 결합이 심한 시스템은 다음과 같은 문제를 겪는다:

#### ❌ 문제가 되는 부분들

* **하나의 이벤트가 늦어지면 전체 시스템이 지연된다**
* **사용자가 특정 순서를 어기면 에러가 난다**
* **테스트가 어렵고 변경이 고통스럽다**
* **병렬 처리나 확장이 어렵다**

반면, 시간적 결합을 제거하면:

#### ✅ 얻는 이점들

* 시스템이 훨씬 안정적이고 탄력적이 된다
* 병렬 실행으로 성능이 자연스럽게 올라간다
* 변경하기 쉬운 구조가 된다
* Race Condition에 강한 구조가 된다
* 이벤트 기반 아키텍처를 설계하기 쉬워진다

특히 오늘날의 아키텍처—SSE, Webhook, 이벤트 스트림, Kafka, 메시지 큐—에서는\
이 개념이 사실상 **필수**이다.

***

#### ✔ 순서가 필요한 것과 중립적인 것을 반드시 구분하라

#### ✔ 동시 수행 가능한 부분을 찾아 분리하라

#### ✔ 활동 다이어그램 등을 활용해 작업 흐름을 ‘시각화’하라

#### ✔ 순차 실행 때문에 병목이 생기면 병렬화/비동기화를 고려하라

#### ✔ 이를 통해 시스템은 더 안정적이고 유지보수하기 쉬워진다

***

### a

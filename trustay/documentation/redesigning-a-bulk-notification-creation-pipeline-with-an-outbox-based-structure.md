---
description: 대량 알림 생성 파이프라인 재설계
---

# Redesigning a Bulk Notification Creation Pipeline with an Outbox Based Structure

(사내 보안 규정에 따라 실제 서비스·테이블·코드 식별자는 모두 일반화되어 있습니다)

## Outbox 기반 큐 구조로 알림 생성 안정성과 운영 안전장치 확보하기

대량 알림(인기 콘텐츠, 위치 기반 글, 운영자 등로 알림) 을 안정적으로 생성하고 운영 리스크를 줄이기 위해,\
기존의 즉시 생성 / 즉시 발송 중심 구조를 **큐 기반(outbox) 생성 구조로 전환**했습니다.

단순히 "큐를 도입했다"가 아니라,

* 왜 기존 구조가 한계에 부딪혔는지,
* 어떤 기준으로 구조를 재정의했는지
* 운영 관점에서 무엇이 좋아졌고, 무엇을 포기했는지

를 **문제 -> 판단 -> 설계 -> 결과 -> 트레이드 오프** 흐름으로 작성합니다.



## TL;DR

#### 문제

대량 알림 생성 작업이 동시에 실행되는 상황이 발생하면서 DB CPU 스파이크가 발생했고, 작업 중단 기능이 없어 pod를 강제 종료 후 다시 띄웠습니다. 또한 재시작 시 어디까지 처리됐는지 추적할 수 없었습니다.

#### 해결

대량 알림 생성을 즉시 실행이 아닌 **작업 큐(job queue) + 커서(cursor)** 기반으로 관리하도록 구조를 전환했습니다.

#### 효과

단일 실행 보장(single-flight), 부분 재처리, stuck job 복구가 가능해졌고 운영 리스크가 감소했습니다.

#### 남은 과제

향후 운영 상황에서 작업을 즉시 멈출 수 있는 Abort(중단) 제어 기능을 추가할 계획입니다.



## 배경 1. 용어 정리

* **채널**: 각 사용자는 시스템 내에서 하나의 채널을 가지며, 알림의 실제 수신 단위는 사용자 계정이 아닌 채널입니다.
* **알림 센터**: 앱/서비스 내부에 노출되는 알림 목록으로, 채널 단위로 누적됩니다.
* **푸시**: 단말로 전달되는 실시간 알림 메시지입니다.
* **생성 큐**: 대량/예약 알림을 생성 작업 단위로 적재하는 큐 테이블입니다.

## 배경 2. 전체 알림 유형

알림은 크게 4가지 유형으로 나뉩니다.

#### 인기 콘텐츠 알림 (대량)

* 일정 주기마다 조회수가 높은 콘텐츠를 선정
* 알림 센터 적재 + 푸시 발송
* 대상 채널 수가 많아 대량 생성에 해당

#### 위치 기반 질문 알림 (대량)

* 운영자가 특정 콘텐츠를 "질문 콘텐츠"로 지정
* 콘텐츠 위치 기준 일정 반경 내 채널에 알림 생성

#### 운영자 등록 알림 (대량)

* 운영자가 제목/내용을 직접 작성
* 전체 또는 특정 플랫폼에 알림 센터 + 푸시 발송

#### 채널 활동 알림 (소량)

* 좋아요, 댓글, 팔로우 등 사용자 활동 기반 알림
* 즉시성이 중요하고 대상 규모가 적음



## 문제 인식 - 기존 구조의 한계

<div align="center" data-full-width="true"><figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure></div>

초기 설계는 요구사항을 빠르게 충족하는데 초점이 맞춰져 있었고, 각 알림은 다음과 같이 처리되었습니다.

* 인기 콘텐츠: 스케줄러가 특정 시점에 즉시 생성
* 질문 콘텐츠: 관리자가 지정하는 순간 즉시 생성
* 운영자 알림: 콘솔 등록 즉시 생성

이 구조는 다른팀의 "시간표" 기반 운영을 참고하였고 시간표를 공유하였지만, 팀 내부에서 지켜지지 않아 운영에서 여러 문제가 드러나게 됐습니다.



### 1) DB CPU 스파이크

대량 알림 생성 작업이 동시에 실행되면서 DB CPU 사용률이 급격히 상승했고, 최악의 경우 순간적으로 100%에 도달해 서비스 인스턴스를 강제 종료해야했습니다.

### 2) 재처리 불가 구조

알림 생성과 푸시 생성이 하나의 흐름으로 엮여 있었기 때문에, 작업이 중간에 실패하면 **어디까지 처리됐는지 추적할 수 없었고**, 이후 구간은 소실되거나 중복 생성될 위험이 있었습니다.

### 3) 운영 제어 포인트 부재

알림 종류가 늘어날수록 케이스별 분기와 중복 코드가 증가했고, 운영자가 작업을 관찰, 제어할 수 있는 명확한 기준점이 없었습니다.



## 목표 설정

#### 1. Single-flight

대량 알림 생성 작업은 한번에 하나만 실행

### 2. Idempotency / 재시도 가능성

중단되어도 이어서 처리 가능

### 3. Self-healing

장시간 갱신이 없는 작업(stuck job)을 감지하고 복구

### 4. 확장성

대량 알림을 하나의 그룹으로 관리



## 해결 전략 - Outbox 기반 생성 큐 도입

핵심 설계 결정은 **"대량 알림 생성을 즉시 실행하지 않는다"** 였습니다.

### 핵심 아이디어

즉시 생성 구조를 버리고,

* 알림 생성 요청을 job queue에 적재
* 배치 프로세스가 이를 순차적으로 소비
* 진행 상태를 cursor로 기록

하는 방식으로 전환했습니다.



## 설계 1. 생성 큐(Job Queue) 구조

각 대량 알림 요청은 하나의 작업으로 큐에 저장됩니다.

<div data-full-width="true"><figure><img src="../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure></div>

### 주요 개념

* **작업 타입**: 알림 센터 생성/ 푸시 생성
* **작업 카테고리**: 인기 콘텐츠 / 질문 콘텐츠 / 운영자 알림
* **스케줄 시간**: 예약 실행 시점
* **작업 상태**: PENDING -> PROCESSING -> PROCESSED
* **처리 오프셋**: 마지막으로 처리한 채널 위치

이 구조를 통해 작업의 목적, 대상, 진행 상태를 명확히 분리했습니다.



## 설계 2. Cursor 기반 처리

대량 알림은 모든 채널을 한번에 처리 하지 않습니다.\
기존 정의된 메서드들을 충분히 확인하지 않고 재사용했었습니다.

* 채널을 일정 크기(chunk)로 나누어 순회
* 각 chunk 처리 후 cursor 업데이트
* 장애 발생 시 cursor 이후부터 재개

이 방식으로,

* 부분 재처리 가능
* 중복 최소화
* 장시간 작업에 대한 안정성

을 확보했습니다.



## 설계 3. Single-flight 보장

배치 프로세스는 아래의 규칙을 따릅니다.

<figure><img src="../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

* RUNNING 상태의 job이 있으면 신규 job 실행 금지
* 오래 갱신되지 않은 RUNNING job은 stuck job으로 판단
* 복구 대상 job은 cursor 기준으로 재시작

이를 통해 대량 생성 작업이 병렬로 실행되는 상황 자체를 제거했습니다.



## 설계 4. Abort(중단 제어)

운영 중 예상치 못한 상황에서 즉시 작업을 멈출 수 있는 제어 포인트

* Admin Console에서 작업 중단 버튼 제공
* 중단 플래그를 캐시 기반으로 처리
* chunk 처리 전 중단 여부 확인
* 중단 후 cursor 기준 재시작 지원

을 하게 되면서 강제 인스턴스 종료 없이도 운영 대응이 가능해졌습니다.



## 결과

#### 1. DB 안정성

대량 알림 생성이 순차적으로 실행되면서 CPU 스파이크 문제가 사라졌고, DB 부하가 예측 가능한 범위로 안정되었습니다.

#### 2. 운영 가시성

운영자는 아래의 정보들을 알 수 있게 됐습니다. (cursor를 활용한 백오피스 프론트 작업)

* 어떤 대량 알림 작업이 실행 중인지
* 어디까지 처리됐는지
* 중단되었는지, 완료되었는지

#### 3. 장애 대응력

서버 재시작이나 예외 상황에서도 작업은 cursor 기준으로 이어서 처리되며, 재처리를 위한 수동 개입이 크게 줄었습니다.



## 트레이드 오프

* 큐 테이블이 범용화되며 컬럼 수 증가
* chunk 단위 처리로 전체 처리 시간 증가
* exactly-once 대신 at-least-once에 가까운 보장

대량 알림의 특성상 완벽한 즉시성보다 안정성과 운영 안전성이 중요하다고 생각됐습니다.




---
description: '대량 생성 시 DB CPU 스파이크 해결: 생성 큐 테이블 도입과 스케줄러 기반 배치 생성 구조로 전환'
---

# Page 1

(사내 보안 규정에 따라 실제 서비스, 테이블, 코드 식별자는 모두 일반화되어 있습니다)



## 배경

초기 알림 시스템은 "이벤트 밠생 -> 즉시 알림/푸시 생성" 구조를 기반으로 설계되어 있었습니다.\
도메인 이벤트가 발생하면 해당 요청 흐름 안에서 바로 알림 데이터를 생성하고 저장하는 방식이었습니다.

이 구조는 소량 트래픽 환경에서는 문제가 없었지만,\
**대량 알림 시나리오가 추가**되면서 한계가 나타났습니다.

* 트랜딩 포스트
* 위치 기반 포스트
* 운영 알림

이러한 알림들은 공통적으로:

* 대상 유저 수가 많고,
* 필터링 로직이 복잡하며,
* 한 시점에 대량으로 생성됨

이라는 특징을 가지고 있었습니다.

운영 중 실제로 문제가 발생했습니다.

* '시간표'를 정했으나, 잘 지켜지지 않아 대량 알림 생성이 동시에 여러건 겹쳐 DB CPU 급증
* 짧은 시간 동안 대량 Insert가 몰려서 CPU 스파이크 발생
* DB CPU 사용률이 임계치를 초과하여 파드 강제 종료 및 운영 개입



## 원인 파악

운영팀으로부터 위치 기반 포스팅 등록 시 오류가 발생했다는 상황을 공유받았습니다.

1. 1차적으로 로그를 확인했지만 해당 오류를 찾을 수 없었고, 서비스도 정상 동작하는 것을 확인했습니다.
2. 처리 속도가 늦어지면서 time-out 발생을 의심했고, DB CPU를 확인했습니다.

문제의 핵심은 "즉시 생성"이라는 처리 방식이었습니다.

알림 생성 로직이

* 도메인 이벤트
* 운영 요청
* 스케줄러

등 여러 진입점에서 동시에 실행이 되면서, CPU 임계치를 초과한 상태로 천천히 처리되고 있었습니다.

각 생성 로직은 독립적으로 동작하고 있었고, 서로의 실행 여부를 확인하고 있지 않는 구조였습니다.

그 결과:

* 대량 생성 작업이 병렬로 실행
* 순간적으로 DB에 큰 쓰기 부하 집중
* 생성 작업의 실행 순서, 진행 상태를 추적할 수 있는 방법이 없었고,
* 작업을 중간에 중단하였을때 어디까지 처리되었는지 알 수 없었습니다.

알림 생성이 대량 작업임에도 불구하고, **동시 요청 처리**가 되고 있던게 가장 큰 문제였습니다.



## 해결 방법

### 생성 큐 테이블 + 스케줄러 기반 배치 처리(O)

순차적으로 처리될 수 있도록 outbox를 도입했습니다.

#### 방식

* 알림 생성을 즉시 실행하지 않고 큐에 적재
* 실제 생성은 스케줄러가 큐를 소비하며 순차 처리

#### 기술적 동작

* 대량 알림 요청 발생 시:
  * 알림 데이터를 바로 생성하지 않고, "알림 생성 작업"을 큐 테이블에 저장.
  * 이때 "알림센터 알림+앱A 푸시+앱B 푸시"로 작업 단위를 작게 나눴습니다.
* 스케줄러가 주기적으로 큐를 조회하여
  * 처리 중인 작업이 없을 경우 하나의 작업만 가져와 실행
  * 처리 중인 작업이 있을 경우, 처리 진행도와 시간을 확인하여 처리중/중단 판별
  * 대상 유저를 커서 기반으로 순회하며 배치 생성
  * 처리 진행도를 함께 기록

위 방식은 비동기 전환이 아닌, 알림 생성을 '작업 단위'로 모델링한 구조적 변경이었습니다.



## 핵심 설계

* 알림 생성은 즉시 실행하지 않는다.
* 대량 알림 생성 = 하나의 Job
* 생성 큐 테이블에:
  * 작업 유형
  * 상태
  * 진행도를 관리
* 스케줄러는:
  * 한번에 하나의 작업만 실행 (single-flight)
  * 커서 기반으로 대상 채널 순회
  * Chunk 단위로 생성하여 DB 부하 제어

이를 통해:

* 대량 생성 작업의 동시 실행 차단
* 작업 진행 상태를 데이터로 추적 가능
* 중단 시에도 이어서 자동 재처리 가능



## 결과

* DB CPU 스파이크 문제 해소: 대량 알림 생성이 순차적으로 실행되며 부하 평준화
* 운영 안정성 확보: pod 강제 종료 없이 대량 알림 처리 가능
*

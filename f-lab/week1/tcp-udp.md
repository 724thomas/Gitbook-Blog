# TCP/UDP

## TCP

TCP는 신뢰성 있는 데이터 전송을 보장하는 연결 지향적 프로토콜이며 전송 계층의 프로토콜.



### 특징

1. 연결지향

데이터 전송을 시작하기 전에 송신자와 수신자간의 연결을 설정

2. 신뢰성

TCP는 데이터가 정확하고 순서대로 전달되도록 보장. 손실된 패킷은 재전송, 중복 패킷은 삭제, 순서가 어긋난 패킷은 재정렬.

3. 흐름제어

송신자가 수신자의 처리 능력을 초과하지 않도록 데이터를 조절하는 흐름 제어를 수행

4. 오류 검출 및 수정

전송된 데이터에 대한 체크섬을 포함하고, 오류가 발견되면 데이터를 재전송. 데이터에 대해 계산된 체크섬을 포함하여 보내고, 수신측에서 체크섬을 다시 계산하여 비교를 통해 손상됬는지 확인



### 순서 보장 메커니즘

Hello World! 를 5바이트로 나뉘어서 보내는 상황

1. 클라이언트 -> 서버: \[Seq=1000, Data="Hello"]
2. 서버 -> 클라이언트: \[Ack=1005]. 1000을 받았고, 다음 1005를 요청하는 Ack
3. 클라이언트 -> 서버: \[Seq=1005, Data="World"]. 서버의 요청대로 1005를 보냄.
4. 클라이언트 -> 서버: \[Seq=1010, Data="!"]. 그 다음 1010을 보냄.
5. 서버 -> 클라이언트: \[Ack=1005]. 1000을 받았고, 다음 1005를 요청하는 Ack. (1005번째가 손실)
6. 클라이언트 -> 서버: \[Seq=1005, Data="World"]. 서버의 요청대로 1005를 다시 보냄.
7. 서버 -> 클라이언트: \[Ack=1015]. 서버는 1005를 받고, 1010도 받았으므로 1015를 요청.

### 흐름 제어 메커니즘

클라이언트A가 서버B에게 대량의 데이터를 전송하려고 준비합니다. 서버B의 수신 버퍼는 한정되어 있으므로, 클라이언트A가 서버B의 수신 버퍼를 초과하지 않게끔 흐름 제어가 필요합니다.

1.  초기 상태

    클라이언트A와 서버B 간에 TCP 연결을 합니다.

    서버B의 초기 수신 윈도우 크기는 5,000입니다.
2. 클라이언트A가 서버B에게 데이터 전송 시작 \
   클라이언트A는 서버B의 수신 윈도우 크기(5,000)을 확인한 후, 4,000 바이트의 데이터를 전송합니다. \
   **클라이언트 -> 서버: \[시퀀스 번호 = 1000, 데이터 = 4000 바이트]**
3. **서버B가 데이터 수신 및 확인 응답 전송** \
   서버(B)는 데이터를 수신하고, 이를 처리한 후 수신 윈도우 크기를 1000 바이트로 줄여 클라이언트(A)에게 알립니다. \
   **서버 -> 클라이언트: \[ACK, 확인 응답 번호 = 5000, 수신 윈도우 크기 = 1000 바이트]**
4. 클라이언트A가 추가 데이터 전송 \
   클라이언트A는 서버B의 수신 윈도우 크기를 확인하고, 1,000 바이트의 데이터를 추가로 전송합니다. \
   **클라이언트 -> 서버: \[시퀀스 번호 = 5000, 데이터 = 1000 바이트]**
5. 서버 B가 데이터 수신 및 확인 응답 전송 \
   서버(B)는 데이터를 수신하고, 응답을 처리한 후, 수신 버퍼를 비우면서 수신 윈도우 크기를 5000 바이트로 다시 늘립니다. \
   **서버 -> 클라이언트: \[ACK, 확인 응답 번호 = 6000, 수신 윈도우 크기 = 5000 바이트]**

### **혼잡 제어 메커니즘**

네트워크 과부하를 방지하고 패킷 손실과 지연을 줄이기 위해 설계됨. 네트워크의 혼잡 상태를 감지하고, 그에 맞춰 송신 측의 데이터 전송 속도를 조절하는 메커니즘.

* Slow Start (느린 시작): 임계점까지 1부터 2배씩 윈도우 크기를 늘립니다.
* Congestion Avoidance (혼잡 회피): 임계점부터는 1씩 선형적으로 증가.
* Fast Recovery (빠른 복구): 혼잡이 발생하면 혼잡 윈도우를 절반으로 줄인 후 다시 혼잡 회피.
* Fast Retransmit (빠른 재전송): 중복된 ACK가 3번 발생하면 타이머를 기다리지 않고 재전송.

### 빠른 재전송 메커니즘

패킷 손실이 발생했을때, 빠르게 감지하고 재전송을 신속히함. 원래는 Time-out을 기다립니다.

재전송 속도:

* 타임아웃으로 인해 손실 감지 및 복구 시간이 걸림
* 중복 ACK로 손실을 빠르게 감지하고 즉시 재전송

네트워크 지연:

* 손실 복구 대기 시간 증가로 인해 전송 지연이 큼.
* 손실 복구 시간이 짧아 지연이 최소화됨

혼잡제어 효율성:

* 네트워크 혼잡으로 잘못 해석하여 혼잡 윈도우를 줄이게 될 수 도 있음.
* 네트워크 혼잡 상태를 정확히 판단함.

상황:

1. 송신자는 패킷1\~4를 연속적으로 전송.
2. 송신자는 패킷5\~8을 보내기 전에 1\~4에 대한 ack를 기다립니다. 이떄 빠른 재전송이 없다면 time-out이 될때까지 기다립니다.
3. 패킷3이 손실된다면 2, 3, 4, 4 ack를 보내게 됩니다. (1\~3에 대한 ack)
4. 이떄 4가 2번 온것을 확인하여 3번째 패킷이 도착하지 않은것으로 확인합니다. time-out을 기다리지 않고 바로 재전송을 하게 됩니다.





## UDP

비연결 지향적이고 신뢰성을 보장하지 않는 프로토콜이며 전송 계층의 프로토콜.

### 특징

* 비연결 기반
* 신뢰성 없음
* 빠른 전송 속도
* 멀티캐스트/브로드캐스트 지원

### 비연결 지향

데이터를 전송하기전 송신자와 수신자의 연결 설정을 하지 않음.

* 목적지 주소와 데이터를 전송하며, 수신자가 수신하면 끝.
* 3-way handshake 생략
* 간단한 통신 프로세스와 재전송 생략으로 빠른 전송 속도.
* 데이터 손실, 중복, 순서 뒤바뀜 가능

### 신뢰성 없음

데이터를 받지 못해도 재전송 요청을 하지 않음

* 패킷 손실: 네트워크 혼잡으로 손실될 경우 복구 X
* 중복 패킷: 동일한 데이터그램이 중복 수신 가능
* 순서 보장 없음: 데이터그램은 독립적으로 전달되므로, 수신자가 데이터를 전송 순서대로 받는다는 보장이 없음.

### 빠른 전송속도

* UDP는 신뢰성, 연결 설정, 흐름 제어 등 부가적인 작업이 없음
* 연결 설정 없음
* 수신자의 응답을 기다리지 않음
* 헤더의 크기가 작음 (Source Port, Dest Port, Length, Checksum)

### 멀티캐스트와 브로드캐스트 지원

* 멀티캐스트: 특정 그룹의 수신자에게 데이터를 전송
* 브로드캐스트: 네트워크 상의 모든 호스트에게 데이터를 전송




---
description: 의존성 주입
---

# Dependency Injection

## 의존성 주입이 무엇인가요? 왜 중요한가요?

* **객체 간의 의존 관계를 외부에서 설정**하고 주입하는 방식. 객체가 직접 다른 객체를 생성하는 대신, 필요한 객체를 외부에서 주입받음으로써 **유연하고 확장 가능한 구조**를 만들 수 있습니다.
* 주로 스프링 컨테이너가 이러한 주입을 처리합니다.
* **결합도 감소**: 객체가 직접 다른 객체를 생성하지 않기 때문에, 서로 강하게 결합되지 않고 더 유연한 구조
* **테스트 용이성**: Mock 객체를 쉽게 주입할 수 있어 단위 테스트가 훨씬 간단
* **유지보수성 향상**: 의존성 변경이 필요할 때 코드의 수정 범위가 줄어들어 유지보수가 쉬워집니다.
* **객체 생명주기 관리**: 스프링 컨테이너가 객체의 생명주기를 관리하기 때문에 효율적인 자원 관리



## 의존성 주입을 처리하는 세가지 방법은 무엇인가요?

생성자 주입: 객체가 생성될 때 필요한 의존성을 **생성자를 통해 주입**받습니다. 의존성이 없는 객체는 인스턴스화될 수 없습니다. (RequiredArgsConstructor로 자동 주입)

* **불변성 보장**: 의존성이 모두 final로 선언될 수 있어 객체가 불변 객체
* **강한 의존성 표현**: 필수적인 의존성을 강제할 수 있어 객체가 필요한 의존성 없이 인스턴스화되지 않도록 보장
* **테스트 편의성**: 객체 생성 시점에 필요한 의존성을 바로 주입받기 때문에 테스트가 더 쉽습니다.
* **단점**: 의존성이 많을 경우 생성자가 너무 길어질 수 있습니다.

Setter 주입: 객체 생성 후에 의존성을 **Setter 메서드를 통해 주입**받습니다.

* **선택적 의존성**: 필수가 아닌 의존성을 나중에 주입할 수 있어 유연한 객체 구성이 가능
* **가독성**: 의존성이 많을 때 하나씩 설정하기 때문에 가독성이 높아집니다.
* 단점: **객체의 불완전성 가능성**: 의존성을 나중에 주입받기 때문에 주입되지 않은 상태에서 객체가 사용될 위험
* 단점: **필수 의존성 표현 불가**: 필수 의존성을 강제할 수 없습니다.

필드 주입(Autowired): 의존성을 클래스의 **필드에 직접 주입**합니다. 주로 `@Autowired`를 필드에 직접 붙입니다.

* **간결성**: 코드가 매우 간단하고 주입을 바로 필드에 할 수 있어 구현이 쉽습니다.
* 단점: **테스트 어려움**: 필드를 직접 주입받기 때문에 Mocking이나 테스트 시에 별도의 설정이 필요해 테스트가 어렵습니다.
* 단점: **객체 불변성 감소**: 필드 주입은 객체의 불변성을 보장하지 않으며, 변경될 수 있는 상태를 가질 수 있습니다.
* 단점: **권장되지 않음**: 스프링 공식 문서에서도 테스트와 유연성을 위해 필드 주입보다는 생성자 주입을 권장합니다.



## 생성자 주입과 Setter 주입중 어느 방식이 권장되고 이유가 뭔가요?

생성자 주입 > Setter 주입

* 불변성 보장: 생성자 주입은 객체가 생성될 때 필요한 의존성을 모두 제공해야 하기 때문에, **객체의 불변성**을 보장할 수 있습니다. (final)
* 필수 의존성 강제: **필수적인 의존성을 명확하게 표현**할 수 있습니다. 의존성이 없으면 객체가 생성되지 않으므로, 의존성이 누락된 상태로 객체가 사용되는 것을 방지
* 테스트 용이성: 생성자 주입은 테스트 시에 의존성을 **명시적으로 전달**할 수 있기 때문에, 단위 테스트 작성이 더 쉽습니다. Mock 객체를 쉽게 주입할 수 있어 테스트할 때의 유연성이 높습니다.
* 생성자 주입은 순환 의존성을 미리 체크할 수 있습니다. 두 객체가 서로를 필요로 하는 상황이 발생하면 컴파일 타임이나 애플리케이션 초기화 단계에서 오류를 발생



## 필드 주입이 테스트와 유지보수 측면에서 권장되지 않는 이유는 뭔가요?

* **테스트 어려움: 필드 주입시에는 주입된 필드를 직접 수정하기 어려워서 Mock 객체나 테스트용 의존성을 주입하는 과정이 복잡해집니다.**
* **객체의 불완전한 상태: 필드 주입은 객체가 생성된 후에 의존성이 주입되기 때문에, 의존성이 주입되기 전에 객체가 사용될 위험이 있습니다.**
* **불변성 보장 불가: 필드 주입은 객체가 생성된 후에도 의존성을 변경할 수 있는 구조입니다.**
* **순환 의존성 문제: 런타임에 발견됩니다.**



## Spring에서 의존성 주입을 통해 순환 의존성을 해결하는 방법에는 어떤 것들이 있나요?

* **순환 의존성**은 두 개 이상의 빈이 서로를 의존하는 경우 발생합니다. 설계가 잘못된 경우가 대다수이지만, 불가피한 경우에는 Setter 주입을 사용할 수 있습니다.
* **Setter 주입**을 사용하면, 빈을 먼저 생성하고 나중에 의존성을 주입할 수 있기 때문에 순환 의존성을 해결



## 의존성 역전 원칙(DIP)이란 무엇인가요? 스프링에서 이를 어떻게 구현할 수 있나요?

* **의존성 역전 원칙**은 **SOLID 원칙** 중 하나로, 소프트웨어 모듈 간의 결합도를 낮추기 위해 사용
* "구체적인 구현에 의존하지 말고, 추상화된 인터페이스에 의존하라."
* **고수준 모듈**은 **저수준 모듈**에 의존해서는 안 됩니다.  고수준 모듈과 저수준 모듈 모두 **추상화된 인터페이스**에 의존해야 합니다.
* **추상화**는 **구체화**에 의존하지 않습니다. 즉, 구체적인 클래스가 추상화를 의존하는 방식이 아니라, **추상화**된 인터페이스가 구체화된 구현을 의존하지 않도록 해야 합니다.


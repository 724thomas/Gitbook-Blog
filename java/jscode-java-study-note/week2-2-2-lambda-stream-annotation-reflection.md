---
description: 람다, 스트림, 어노테이션, 리플렉션
---

# Week2(2/2) Lambda, Stream, Annotation, Reflection

## 11. 람다(Lambda)란 무엇인가요?

**11.1 람다의 정의**

람다(Lambda)는 자바 8에서 도입된 함수형 프로그래밍 개념을 지원하는 표현식입니다. 람다는 익명 함수(이름이 없는 함수)를 간단하게 표현할 수 있게 해주며, 코드의 간결성을 높이고, 자바에서 함수형 인터페이스를 쉽게 구현할 수 있게 해줍니다.

**11.2 람다의 기본 구조**

람다 표현식의 기본 구조는 다음과 같습니다:

```java
(parameters) -> expression
```

또는 블록이 필요한 경우:

```java
(parameters) -> { statements; }
```

**11.3 예시: Runnable 인터페이스 구현**

람다를 사용하여 `Runnable` 인터페이스를 구현하는 예시입니다.

```java
// 람다를 사용하지 않은 경우
Runnable runnable = new Runnable() {
    @Override
    public void run() {
        System.out.println("Runnable 실행");
    }
};

// 람다 표현식을 사용한 경우
Runnable lambdaRunnable = () -> System.out.println("Runnable 실행");
```

위 예시에서 볼 수 있듯이, 람다 표현식을 사용하면 불필요한 코드가 줄어들고, 더 간결하게 코드를 작성할 수 있습니다.

**11.4 람다의 장점**

* **코드 간결성**: 람다를 사용하면 코드가 간결해져 가독성이 높아집니다.
* **익명 함수 표현**: 인터페이스의 단일 메서드를 간단하게 구현할 수 있습니다.
* **지연 실행**: 람다는 코드의 지연 실행을 지원하여 메모리 사용량을 줄일 수 있습니다.

## 12. 스트림(Stream)이란 무엇인가요?

**12.1 스트림의 정의**

스트림(Stream)은 자바 8에서 도입된 컬렉션 데이터의 반복, 필터링, 매핑 등의 작업을 선언적으로 처리할 수 있는 API입니다. 스트림을 사용하면 대량의 데이터를 처리하는 코드를 간결하고, 직관적으로 작성할 수 있습니다.

**12.2 스트림의 주요 특징**

* **선언적 코드**: 스트림은 데이터를 어떻게 처리할지를 선언적으로 표현합니다. 이는 코드의 가독성을 높입니다.
* **중간 연산과 최종 연산**: 스트림은 중간 연산(intermediate operation)과 최종 연산(terminal operation)으로 나뉩니다. 중간 연산은 스트림을 반환하며, 최종 연산은 결과를 반환하거나 스트림의 요소를 소비합니다.
* **게으른 연산**: 스트림은 필요할 때까지 계산을 지연시킵니다. 즉, 최종 연산이 호출될 때까지 중간 연산은 수행되지 않습니다.
* **병렬 처리 지원**: 스트림은 간단한 코드 수정만으로도 병렬 처리를 지원하여 성능을 최적화할 수 있습니다.

**12.3 스트림의 예시**

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// 필터링과 매핑을 통한 스트림 처리
List<String> result = names.stream()
                           .filter(name -> name.startsWith("A"))
                           .map(String::toUpperCase)
                           .collect(Collectors.toList());
```

위 코드에서 `names.stream()`을 통해 스트림을 생성하고, 필터링과 매핑 연산을 적용하여 원하는 결과를 얻을 수 있습니다.

**12.4 스트림의 장점**

* **간결한 코드**: 스트림을 사용하면 데이터 처리 로직을 간결하게 작성할 수 있습니다.
* **유연한 데이터 처리**: 다양한 중간 연산과 최종 연산을 조합하여 복잡한 데이터 처리도 쉽게 구현할 수 있습니다.
* **병렬 처리**: 대용량 데이터 처리 시 병렬 스트림을 사용하여 성능을 향상시킬 수 있습니다.

## 13. 람다와 스트림은 왜 생겨났을까요?

**13.1 배경**

람다와 스트림이 도입되기 전, 자바에서는 익명 클래스를 통해 함수형 인터페이스를 구현하거나 반복문을 사용하여 데이터를 처리해야 했습니다. 이러한 방식은 코드가 장황해지고, 반복적인 패턴이 발생하며, 코드의 가독성이 떨어지는 문제가 있었습니다.

**13.2 람다의 필요성**

람다는 익명 클래스의 장황한 구문을 간결하게 줄여주며, 함수형 인터페이스를 더 쉽게 구현할 수 있도록 도와줍니다. 이는 자바에서 함수형 프로그래밍을 지원하는 중요한 도구가 되었습니다.

**13.3 스트림의 필요성**

스트림은 대량의 데이터를 처리할 때 발생하는 반복적인 코드를 줄이고, 선언적으로 데이터를 처리할 수 있게 합니다. 또한, 스트림은 병렬 처리 기능을 지원하여, 멀티코어 환경에서의 성능 최적화를 가능하게 합니다.

**13.4 순수 함수와 사이드 이펙트의 방지**

람다와 스트림은 순수 함수(pure function)의 개념을 기반으로 합니다. 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환하며, 외부 상태를 변경하지 않습니다. 이를 통해 코드의 예측 가능성을 높이고, 사이드 이펙트가 발생하지 않도록 보장합니다.

## 14. 자바에서 어노테이션이란 무엇일까요?

**14.1 어노테이션의 정의**

어노테이션(annotation)은 자바 소스 코드에 메타데이터를 제공하는 일종의 주석입니다. 주로 컴파일러에게 정보를 제공하거나, 런타임에 특정 동작을 수행하기 위해 사용됩니다. 어노테이션은 코드의 특정 요소(클래스, 메서드, 변수 등)와 연관된 정보를 전달하는 데 사용됩니다.

**14.2 어노테이션의 기본 구조**

어노테이션은 `@` 기호로 시작하며, 특정 메타데이터를 포함합니다.

```java
public class Example {
    @Override
    public String toString() {
        return "Example class";
    }
}
```

위 예시에서 `@Override` 어노테이션은 해당 메서드가 슈퍼 클래스의 메서드를 오버라이드하고 있음을 컴파일러에게 알려줍니다.

**14.3 자주 사용하는 어노테이션**

* `@Override`: 메서드가 슈퍼 클래스의 메서드를 오버라이드하고 있음을 나타냅니다.
* `@Deprecated`: 더 이상 사용되지 않으며, 앞으로 제거될 예정임을 나타냅니다.
* `@SuppressWarnings`: 컴파일러 경고를 무시하도록 지시합니다.

**14.4 커스텀 어노테이션**

자바에서는 사용자 정의 어노테이션을 만들 수 있습니다. 예를 들어, 특정 메서드가 실행되기 전에 로그를 기록하는 어노테이션을 만들 수 있습니다.

```java
java코드 복사@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface LogExecutionTime {
}
```

## 15. 어노테이션을 왜 사용할까요?

**15.1 코드 가독성 및 유지보수성 향상**

어노테이션은 코드에 메타데이터를 추가함으로써, 코드의 가독성과 유지보수성을 향상시킬 수 있습니다. 예를 들어, `@Override` 어노테이션을 사용하면 오버라이드된 메서드임을 명확히 알 수 있어, 코드의 이해도를 높일 수 있습니다.

**15.2 메타데이터 제공**

어노테이션은 컴파일러에게 특정 정보를 제공하거나, 런타임에 리플렉션을 통해 메타데이터를 활용할 수 있도록 도와줍니다. 이를 통해 코드를 자동 생성하거나, 특정 동작을 런타임에 동적으로 적용할 수 있습니다.

**15.3 프레임워크와의 통합**

많은 자바 프레임워크에서 어노테이션을 사용하여 설정을 관리합니다. 예를 들어, 스프링(Spring) 프레임워크에서는 `@Autowired` 어노테이션을 사용하여 의존성 주입을 설정할 수 있습니다. 이는 XML 설정 파일을 사용하는 것보다 직관적이고, 오류를 줄일 수 있습니다.

## 16. 어노테이션은 리플렉션으로 동작한다고 말씀해 주셨는데, 리플렉션은 무엇인가요?

**16.1 리플렉션의 정의**

리플렉션(Reflection)은 자바에서 런타임에 클래스의 메타데이터(클래스 정보, 메서드, 필드 등)를 동적으로 조사하고 조작할 수 있는 기능입니다. 리플렉션을 사용하면 컴파일 타임에는 알 수 없는 객체의 정보를 런타임에 얻을 수 있습니다.

**16.2 리플렉션의 주요 기능**

* **클래스 정보 조회**: 클래스의 이름, 패키지, 상위 클래스 등을 런타임에 조회할 수 있습니다.
* **필드와 메서드 접근**: 클래스의 필드와 메서드에 접근하고, 값을 조회하거나 수정할 수 있습니다.
* **동적 객체 생성**: 리플렉션을 사용하여 클래스의 인스턴스를 동적으로 생성할 수 있습니다.

**16.3 리플렉션의 예시**

```java
Class<?> clazz = Class.forName("com.example.MyClass");
Method method = clazz.getMethod("myMethod");
method.invoke(clazz.newInstance());
```

위 코드에서 리플렉션을 통해 `MyClass`라는 클래스의 메서드 `myMethod`를 동적으로 호출하고 있습니다.

**16.4 리플렉션의 장점**

* **동적 코드 실행**: 컴파일 시점에 알 수 없는 클래스나 메서드를 런타임에 실행할 수 있습니다.
* **프레임워크 개발**: 많은 자바 프레임워크가 리플렉션을 사용하여 애플리케이션의 구조를 동적으로 조작하고, 설정을 자동화합니다.

**16.5 리플렉션의 단점**

* **성능**: 리플렉션은 일반적인 메서드 호출보다 느릴 수 있습니다.
* **안전성**: 컴파일 타임에 타입 검사가 이루어지지 않기 때문에, 런타임에 발생하는 오류가 증가할 수 있습니다.
* **보안**: 리플렉션을 사용하면 일반적으로 접근할 수 없는 필드나 메서드에 접근할 수 있어, 보안 취약점이 발생할 수 있습니다.

## 17. 리플렉션을 활용해서 어노테이션의 메타 데이터를 가져오는 등의 로직을 실제로 구현해 보신 적이 있으신가요?

**17.1 리플렉션과 어노테이션의 연계**

리플렉션을 사용하면 클래스, 메서드, 필드에 선언된 어노테이션의 메타데이터를 런타임에 조회할 수 있습니다. 이를 통해 어노테이션 기반의 설정이나 동작을 동적으로 구현할 수 있습니다.

**17.2 예시: 커스텀 어노테이션 처리**

다음은 리플렉션을 사용하여 커스텀 어노테이션 `@LogExecutionTime`이 붙은 메서드를 찾아 실행 시간을 로깅하는 예시입니다.

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface LogExecutionTime {
}

// 서비스 클래스
public class MyService {
    @LogExecutionTime
    public void serve() {
        // 실행 로직
    }
}

// 리플렉션을 사용한 어노테이션 처리기
public class AnnotationProcessor {
    public static void processAnnotations(Object obj) throws Exception {
        for (Method method : obj.getClass().getDeclaredMethods()) {
            if (method.isAnnotationPresent(LogExecutionTime.class)) {
                long start = System.currentTimeMillis();
                method.invoke(obj);
                long end = System.currentTimeMillis();
                System.out.println(method.getName() + " 실행 시간: " + (end - start) + "ms");
            }
        }
    }

    public static void main(String[] args) throws Exception {
        MyService service = new MyService();
        processAnnotations(service);
    }
}
```

위 코드에서 `AnnotationProcessor`는 `MyService` 클래스의 메서드에 선언된 `@LogExecutionTime` 어노테이션을 리플렉션을 통해 찾아내고, 해당 메서드의 실행 시간을 측정하여 출력합니다.

**17.3 실제 구현 경험**

실제 프로젝트에서 리플렉션을 활용하여 어노테이션 기반의 설정이나 로직을 처리하는 경험이 많습니다. 특히 스프링 프레임워크와 같이 어노테이션을 활용한 설정이 중요한 환경에서, 이러한 기술을 사용하여 다양한 자동화 및 동적 처리를 구현할 수 있었습니다.

## 18. `System.out.println` 클래스는 성능이 좋지 않다고 하는데 이유가 무엇일까요?

**18.1 `System.out.println`의 작동 방식**

`System.out.println`은 콘솔에 메시지를 출력하는 메서드로, 내부적으로는 I/O 작업을 수행합니다. I/O 작업은 일반적으로 CPU 연산보다 시간이 오래 걸리며, 특히 대량의 데이터를 출력할 때 성능에 부정적인 영향을 미칠 수 있습니다.

**18.2 주요 성능 문제**

* **동기화**: `System.out.println` 메서드는 동기화된(synchronized) 메서드입니다. 이는 여러 스레드가 동시에 `println`을 호출할 때, 스레드 간의 경쟁이 발생하지 않도록 보호하지만, 그로 인해 성능 저하가 발생할 수 있습니다.
* **I/O 비용**: 콘솔 출력은 파일 시스템 또는 네트워크를 통해 데이터를 전송하는 것과 같이 느린 I/O 작업을 포함합니다. 이러한 I/O 작업은 시간이 많이 소요되며, 특히 반복적인 출력 작업이 성능 저하의 원인이 될 수 있습니다.
* **버퍼링 미비**: `System.out.println`은 버퍼링 없이 데이터를 즉시 출력하기 때문에, 출력 성능이 저하될 수 있습니다. 반면, `BufferedWriter`와 같은 클래스는 버퍼를 사용하여 I/O 작업을 최적화합니다.

**18.3 성능 최적화 방안**

* **로그 프레임워크 사용**: 성능이 중요한 애플리케이션에서는 `System.out.println` 대신 Log4j, SLF4J와 같은 로그 프레임워크를 사용하는 것이 좋습니다. 이러한 프레임워크는 비동기 로깅, 파일 로깅, 로그 레벨 설정 등의 기능을 제공하여 성능을 개선할 수 있습니다.
* **버퍼링 사용**: `BufferedWriter`와 같은 버퍼링 클래스를 사용하여 출력 성능을 최적화할 수 있습니다.

`System.out.println`은 간단한 디버깅이나 소규모 애플리케이션에서 유용하지만, 대규모 애플리케이션에서는 성능 문제를 야기할 수 있습니다. 이러한 이유로, 성능이 중요한 경우에는 로그 프레임워크나 버퍼링 기술을 사용하는 것이 좋습니다.

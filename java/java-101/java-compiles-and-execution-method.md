---
description: Java의 컴파일과 실행 방식
---

# Java Compiles and Execution Method



<details>

<summary>Compiler vs JVM</summary>



#### 컴파일러 (Compiler)

**Compiler**

컴파일러는 소스 코드를 바이트코드로 변환하는 프로그램입니다. 자바에서 사용되는 컴파일러는 `javac`로, 자바 소스 파일(.java)을 컴파일하여 바이트코드(.class 파일)로 변환합니다.

**주요 기능**

1. **파싱(Parsing)**: 소스 코드를 읽고 문법적으로 분석하여 구문 트리(Syntax Tree)로 변환합니다. 문법 오류를 검출할 수 있습니다.
2. **의미 분석(Semantic Analysis)**: 변수 선언, 타입 검사, 메서드 호출 등이 올바른지 확인합니다. 의미론적 오류를 검출할 수 있습니다.
3. **중간 표현 생성(Intermediate Representation Generation)**: 소스 코드의 구조를 중간 표현으로 변환합니다.
4. **최적화(Optimization)**: 중간 표현을 기반으로 성능을 향상시키기 위해 다양한 최적화를 수행합니다.
5. **바이트코드 생성(Bytecode Generation)**: 최적화된 중간 표현을 바이트코드로 변환하여 .class 파일로 저장합니다.

**컴파일러의 특징**

* **언어 특정적**: 자바 컴파일러는 자바 소스 코드를 바이트코드로 변환하는 데 특화되어 있습니다.
* **정적 분석**: 컴파일 타임에 코드의 문법과 의미를 분석하여 오류를 검출합니다.
* **플랫폼 독립적 바이트코드 생성**: 컴파일러는 자바 소스 코드를 플랫폼에 독립적인 바이트코드로 변환합니다.

***

#### JVM (Java Virtual Machine)

**Java Virtual Machine**

JVM은 자바 바이트코드를 실행하는 가상 머신입니다. JVM은 바이트코드를 해석하고 실행하며, 메모리 관리, 가비지 컬렉션, 스레드 관리 등의 기능을 제공합니다.

**주요 기능**

1. **클래스 로딩(Class Loading)**: 바이트코드(.class 파일)를 메모리에 로드합니다.
2. **바이트코드 검증(Bytecode Verification)**: 클래스 파일의 형식과 구조가 JVM 명세를 준수하는지 확인합니다.
3. **실행(Execution)**: 바이트코드를 해석하고 실행합니다. 인터프리터와 JIT 컴파일러를 통해 실행됩니다.
4. **메모리 관리(Memory Management)**: JVM은 힙, 스택, 메소드 영역 등을 관리합니다.
5. **가비지 컬렉션(Garbage Collection)**: 더 이상 사용되지 않는 객체를 자동으로 메모리에서 제거합니다.
6. **네이티브 메서드 실행(Native Method Execution)**: JNI를 통해 네이티브 메서드를 호출하고 실행합니다.

**JVM의 특징**

* **플랫폼 독립성**: JVM은 한 번 작성된 자바 프로그램을 다양한 플랫폼에서 실행할 수 있게 합니다. 바이트코드는 플랫폼 독립적이지만, JVM은 각 플랫폼에 맞게 구현됩니다.
* **동적 실행**: JVM은 런타임에 바이트코드를 해석하고 실행합니다. JIT 컴파일러를 통해 반복적으로 실행되는 바이트코드를 네이티브 코드로 변환하여 성능을 최적화합니다.
* **메모리 관리 및 가비지 컬렉션**: JVM은 메모리를 효율적으로 관리하고, 가비지 컬렉션을 통해 메모리 누수를 방지합니다.

</details>

#### 컴파일러와 JVM의 비교

| 구분      | 컴파일러 (Compiler)             | JVM (Java Virtual Machine)            |
| ------- | --------------------------- | ------------------------------------- |
| 역할      | 소스 코드를 바이트코드로 변환            | 바이트코드를 실행                             |
| 입력      | 자바 소스 파일(.java)             | 바이트코드(.class)                         |
| 출력      | 바이트코드(.class)               | 프로그램 실행 결과                            |
| 주요 기능   | 구문 분석, 의미 분석, 최적화, 바이트코드 생성 | 클래스 로딩, 바이트코드 검증, 실행, 메모리 관리, 가비지 컬렉션 |
| 실행 시점   | 컴파일 타임                      | 런타임                                   |
| 플랫폼 독립성 | 바이트코드 생성                    | 플랫폼 독립적인 바이트코드를 실행, JVM은 플랫폼에 맞게 구현   |
| 성능 최적화  | 컴파일 타임 최적화                  | JIT 컴파일러를 통한 런타임 최적화                  |

##

## 1. 소스 코드 작성 및 컴파일

자바 소스 코드를 작성한 후, `javac` 컴파일러를 사용하여 자바 바이트코드(.class 파일)로 컴파일합니다. 이 과정에서 자바 소스 코드는 JVM이 이해할 수 있는 바이트코드로 변환됩니다. 예를 들어, `HelloWorld.java` 파일을 작성하고 다음과 같이 컴파일합니다:

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

## 2. 컴파일

### 파싱

컴파일러는 소스 코드를 읽고, 이를 문법적으로 분석하여 구문트리(Syntax Tree)로 변환합니다. 이 단계에서 문법 오류를 검출합니다

### 의미 분석

구문 트리를 기반으로 의미 분석을 수행합니다. 변수 선언, 타입 검사, 메서드 호출 등이 올바른지 확인합니다.

### 중간 코드 생성

중간 코드는 JVM이 이해할 수 있는 명령어 집합으로, 플랫폼 독립적입니다.

### 최적화

중간 코드 생성 후, 컴파일러는 바이트코드를 최적화합니다. 중복 코드 제거, 루프 최적화를 합니다

### 바이트 코드 생성

최적화된 중간 코드는 바이트 코드로 변환되어 .class 파일로 저장됩니다. \\

```java
javac HelloWorld.java -> HelloWord.class 생성
```

이 명령을 실행하면 `HelloWorld.class` 파일이 생성됩니다. 컴파일된 바이트코드는 JVM에서 실행될 준비가 됩니다.

## 3. 클래스 로딩

JVM의 클래스 로더가 .class 파일을 로드하고, 런타임 데이터 영역으로 배치합니다. 이 과정에서 필요에 따라 다른 클래스를 로드하거나 링크합니다. 클래스 로딩은 세 단계로 이루어집니다:

* **로딩(Loading)**: 클래스 파일을 읽고 메모리에 적재합니다.
* **링킹(Linking)**: 클래스 파일의 참조를 확인하고, 기본 초기화를 수행합니다.
  * **검증(Verification)**: 클래스 파일의 형식과 구조가 JVM 명세를 준수하는지 확인합니다. 바이트코드 검증기를 통해 바이트코드의 무결성을 확인합니다.
  * **준비(Preparation)**: 클래스의 정적(static) 변수들을 기본값으로 초기화합니다.
  * **해결(Resolution)**: 상수 풀(Constant Pool)에 있는 심볼릭 레퍼런스를 직접 참조로 변경합니다.
* **초기화(Initialization)**: 클래스 초기화 블록(`static {}`)을 실행하고, 정적 변수들을 적절한 값으로 초기



## 4. 바이트 코드 실행

실행 엔진이 바이트코드를 해석하여 실행합니다. 실행 방식은 인터프리터와 JIT 컴파일러를 통해 이루어집니다:

* **인터프리터(Interpreter)**: 바이트코드를 한 줄씩 읽어 실행합니다. 인터프리터는 프로그램의 초기 시작 속도가 빠르지만, 반복되는 코드를 실행할 때는 비효율적입니다.
* **JIT 컴파일러(Just-In-Time Compiler)**: 반복적으로 실행되는 바이트코드를 머신 코드로 변환하여 캐싱합니다. 이를 통해 실행 속도를 크게 향상시킬 수 있습니다. JIT 컴파일러는 실행 중에 바이트코드의 핫스팟(반복 실행되는 부분)을 찾아 네이티브 코드로 변환합니다. 이렇게 변환된 네이티브 코드는 캐시에 저장되어 이후에 빠르게 실행됩니다.



## 5. 실행 중 메모리 관리

JVM은 실행 중에 메모리를 효율적으로 관리합니다. JVM의 가비지 컬렉터(Garbage Collector)가 주기적으로 힙 메모리를 검사하여 더 이상 참조되지 않는 객체를 제거합니다. 가비지 컬렉션은 크게 다음과 같은 단계로 이루어집니다:

* **마킹(Marking)**: 사용 중인 객체와 사용되지 않는 객체를 식별합니다.
* **정리(Sweeping)**: 사용되지 않는 객체를 메모리에서 제거합니다.
* **압축(Compaction)**: 메모리 단편화를 방지하기 위해 객체들을 한 곳으로 모읍니다.

가비지 컬렉션의 주기와 방식은 JVM의 구현에 따라 다를 수 있으며, 다양한 알고리즘이 사용됩니다. 주요 가비지 컬렉션 알고리즘에는 마크-스위프(Mark-and-Sweep), 마크-컴팩트(Mark-and-Compact), 복사(Copying) 등이 있습니다.



## 6. 네이티브 메서드 실행

자바 애플리케이션이 JNI를 통해 네이티브 메서드를 호출할 때, JVM은 네이티브 메서드 스택과 네이티브 메서드 라이브러리를 사용합니다. 네이티브 메서드는 주로 성능 최적화나 하드웨어 접근을 위해 사용됩니다. 자바 코드가 네이티브 메서드를 호출하면, JVM은 네이티브 라이브러리를 로드하고 해당 메서드를 실행합니다. 네이티브 메서드 실행 후, 제어권은 다시 JVM으로 돌아옵니다.



## 7. 프로그램 종료

자바 애플리케이션이 종료될 때, JVM은 모든 리소스를 해제하고 종료 절차를 밟습니다. JVM은 종료 훅(Shutdown Hook)을 통해 애플리케이션 종료 시 수행할 작업을 정의할 수 있습니다. 종료 훅은 주로 리소스 정리, 로그 기록, 네트워크 연결 종료 등의 작업에 사용됩니다.

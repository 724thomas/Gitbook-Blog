---
description: JVM 구조
---

# JVM Structure

<figure><img src="../../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>

자바VM은 자바 프로그램을 실행하는 가상 머신으로, 여러 구성 요소로 나뉩니다. 주요 구성 요소는 다음과 같습니다:

1. **클래스 로더(Class Loader)**
2. **메모리 영역(Memory Areas)**
   1. 메서드 영역(Method Area)
   2. 힙 (Heap)
   3. PC 레지스터 (PC Register)
   4. JVM 스택 (JVM Stack)
   5. 네이티브 메서드 스택 (Native Method Stack)
3. **실행 엔진(Execution Engine)**
4. **Java Native Interface (JNI)**
5. **네이티브 메서드 라이브러리(Native Method Libraries)**



## 클래스 로더(Class Loader)

클래스 로더는 JVM이 자바 클래스 파일을 동적으로로드하고, 이를 런타임 데이터 영역으로 배치하는 역할을 합니다. 클래스 로더는 계층 구조로 되어 있으며, 주로 세가지 종류가 있습니다.

* Bootstrap ClassLoader: JVM 내부에 내장된 기본 클래스들을 로드합니다.
* Extention ClassLoader: 기본 클래스 외의 추가적인 라이브러리를 로드합니다.
* Application ClassLoader: 애플리케이션 클래스 로더로, 사용자 정의 클래스 및 애플리케이션에서 사용되는 클래스를 로드합니다.



## 메모리 영역

JVM은 실행 중에 다양한 메모리 영역을 사용합니다.

* 메소드 영역: 클래스 메타데이터, 상수, 스태틱 변수 등을 저장합니다.
* 힙: 모든 객체 인스턴스와 배열을 저장합니다
* PC 레지스터: 현재 실행 중인 JVM 명령어의 주소를 가리킵니다.
* 스택: 각 스레드마다 별도로 생성되며, 메서드 호출 시 생성되는 프레임을 저장합니다.
* 네이티브 메서드 스택: 네이티브 메서드 호출 시 사용되는 스택입니다.

<details>

<summary> 단어 설명</summary>

#### 메소드 영역(Method Area)

* **클래스 메타데이터(Class Metadata)**: 클래스에 대한 정보를 포함합니다. 예를 들어, 클래스 이름, 부모 클래스, 메서드 및 필드 정보 등이 있습니다.
* **상수(Constant)**: 프로그램 내에서 변하지 않는 값을 의미합니다. 예를 들어, `final` 키워드로 선언된 변수나 리터럴(literals)이 있습니다.
* **스태틱 변수(Static Variable)**: 클래스 수준에서 선언된 변수로, 모든 인스턴스가 공유합니다. `static` 키워드로 선언됩니다.

#### 힙(Heap)

* **객체 인스턴스(Object Instance)**: 클래스를 통해 생성된 실제 데이터 구조입니다. 예를 들어, `new` 키워드를 사용해 생성된 객체입니다.
* **배열(Array)**: 동일한 타입의 데이터가 연속적으로 저장된 자료 구조입니다. 예를 들어, `int[] arr = new int[10];`와 같은 선언이 있습니다.

#### 스택(Stack)

* **스레드(Thread)**: 프로그램의 실행 단위를 의미합니다. 자바에서는 멀티스레딩을 통해 여러 작업을 동시에 실행할 수 있습니다.
* **메서드 호출(Method Call)**: 프로그램이 메서드를 실행하는 것을 의미합니다. 예를 들어, `object.methodName();`처럼 메서드를 호출합니다.
* **프레임(Frame)**: 메서드 호출 시 생성되는 데이터 구조로, 지역 변수, 파라미터, 반환 주소 등이 포함됩니다.

#### PC 레지스터(Program Counter Register)

* **JVM 명령어(JVM Instruction)**: 자바 바이트코드로 작성된 명령어입니다. JVM이 실행할 수 있는 최소 단위의 코드입니다.
* **주소(Address)**: 메모리의 특정 위치를 가리키는 값입니다. PC 레지스터는 현재 실행 중인 명령어의 위치를 가리킵니다.

#### 네이티브 메서드 스택(Native Method Stack)

* **네이티브 메서드(Native Method)**: 자바가 아닌 다른 프로그래밍 언어(C, C++ 등)로 작성된 메서드입니다. JNI(Java Native Interface)를 통해 호출됩니다.
* **스택(Stack)**: 데이터 구조의 하나로, LIFO(Last In First Out) 원칙에 따라 데이터를 저장하고 제거합니다. 네이티브 메서드 호출 시에도 스택을 사용합니다.

</details>



## 실행엔진

실행 엔진은 JVM의 핵심 구성 요소로, 자바 바이트코드를 실제 머신 코드로 변환하고 실행하는 역할을 합니다. 실행 엔진은 세 가지 주요 컴포넌트로 구성됩니다.

* 인터프리터: 바이트코드를 한 줄씩 읽어 실행합니다. 초기 시작 속도가 빠르지만, 반복되는 코드를 실행할 떄는 비효율적입니다.
* JIT 컴파일러(Just-In-Time): 반복적으로 실행되는 바이트코드를 머신 코드로 변환하여 캐싱합니다. 실행속도를 향상시킵니다.
* 가비지 컬렉터: 더 이상 참조되지 않는 객체를 메모리에서 제거하여 메모리 누수를 방지합니다.



## 자바 네이티브 인터페이스(JNI)

자바 애플리케이션이 C, C++ 같은 네이티브 코드와 상호작용할 수 있게 해주는 인터페이스입니다. JNI를 통해 네이티브 라이브러리를 호출할 수 있으며, 시스템 레벨의 기능을 사용할 수 있습니다.

<details>

<summary>네이티브 라이브러리? 시스템 레벨의 기능?</summary>

#### 네이티브 라이브러리(Native Library)

**정의**

* **네이티브 라이브러리**: C, C++ 등의 언어로 작성된 라이브러리로, 자바 애플리케이션에서 JNI(Java Native Interface)를 통해 호출할 수 있습니다. 네이티브 라이브러리는 자바가 기본적으로 제공하지 않는 저수준의 기능이나 최적화된 성능을 제공합니다.

**용도**

* **성능 최적화**: 일부 연산이나 처리가 자바보다 C/C++에서 더 빠르게 실행될 수 있기 때문에 성능을 최적화하기 위해 네이티브 라이브러리를 사용합니다.
* **플랫폼 종속 기능**: 자바가 추상화한 기능 외에 특정 운영체제나 하드웨어에서만 사용할 수 있는 기능을 접근하기 위해 사용됩니다.
* **기존 코드 재사용**: 이미 존재하는 C/C++ 라이브러리를 재사용하여 개발 시간을 절약하고 기능을 확장할 수 있습니다.

#### 시스템 레벨의 기능(System-Level Functions)

**정의**

* **시스템 레벨의 기능**: 운영체제의 핵심 기능에 직접 접근하거나 제어하는 저수준 기능을 의미합니다. 이러한 기능들은 일반적으로 시스템 콜(System Call)을 통해 접근하며, 파일 시스템, 메모리 관리, 하드웨어 제어 등과 관련된 작업을 포함합니다.

**예시**

* **파일 시스템 접근**: 파일 생성, 읽기, 쓰기, 삭제 등의 작업을 수행합니다.
* **네트워크 통신**: 소켓 프로그래밍을 통해 네트워크 인터페이스를 직접 제어하고 통신을 수행합니다.
* **메모리 관리**: 동적 메모리 할당, 해제, 메모리 맵핑 등을 수행합니다.
* **프로세스 관리**: 프로세스 생성, 종료, 프로세스 간 통신(IPC) 등을 제어합니다.
* **하드웨어 제어**: 특정 하드웨어 장치(예: 프린터, 센서, 그래픽 카드 등)를 제어하고, 직접 상호작용합니다.

</details>



## 네이티브 메서드 라이브러리(Native Method Library)

JNI를 통해 호출되는 네이티브 코드 라이브러리입니다. 성능 최적화 및 하드웨어 접근을 위해 사용됩니다.

<details>

<summary> 자바 네이티 인터페이스 &#x26; 네이티브 메서드 라이브러리</summary>

JNI는 Java 애플리케이션이 네이티브 메서드 라이브러리에 정의된 네이티브 코드를 호출할 수 있도록 하는 인터페이스입니다. 네이티브 메서드 라이브러리는 실제 네이티브 함수들을 포함하고 있으며, 이 함수들은 시스템 콜을 사용하여 하드웨어 접근이나 성능 최적화를 수행할 수 있습니다. Java 애플리케이션이 네이티브 메서드를 호출하면, JNI는 네이티브 메서드 라이브러리에서 해당 함수의 주소를 찾아 호출을 수행합니다.

</details>


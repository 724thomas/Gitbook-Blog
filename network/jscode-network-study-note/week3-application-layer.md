---
description: 애플리케이션 계층
---

# Week3 Application Layer

## 쿠키와 세션에 대해 설명해주세요

쿠키

* HTTP는 기본적으로 **무상태 프로토콜**이기 때문에, 서버는 각 요청 간의 연결 상태를 기억하지 않습니다.
* 서버는 클라이언트에게 **쿠키**를 보내고, 클라이언트는 이후의 요청에 쿠키를 포함시켜 서버에 보냅니다.
* **사용자 세션**, **로그인 상태**, **사용자 선호도** 등을 저장하는 데 사용
* 쿠키는 **클라이언트 측에 저장**되기 때문에 보안 위험이 존재

세션

* **서버 측에서 관리**하는 방식
* 클라이언트에게 **세션 ID**를 할당하고, 이 세션 ID를 통해 클라이언트를 식별하며 관련 데이터를 서버에 저장
* **서버 측에 저장**되므로 더 안전하지만, 서버 자원을 소모하며 사용자가 많아질 경우 서버의 부하가 증가
* 분산 서버 환경에서는 **스티키 세션**을 통해 특정 클라이언트의 요청이 항상 동일한 서버로 전달되도록 설정



## JWT 토큰에 대해 설명해주세요

* 클라이언트와 서버 간에 정보를 안전하게 주고받기 위한 토큰 기반 인증 방식
* JWT는 클라이언트 측에서 **상태를 유지**할 수 있게 해 줍니다. JWT는 주로 **Authorization 헤더**에 담겨 서버에 전달
* Header, Payload, Signature로 나뉩니다.
* **서버 부하가 적고 확장성**이 뛰어납니다.
* **토큰 무효화**가 어렵습니다. 이를 보완하기 위해 **짧은 만료 시간**을 설정하고, **Refresh Token**을 사용



## SOP와 CORS에 대해 설명해주세요

SOP

* 웹 브라우저에서 **보안**을 강화하기 위해 적용되는 정책
* SOP는 클라이언트가 브라우저에서 받은 리소스에 대해 **자바스크립트**를 통해 제3의 서버에 데이터를 요청할 때, 출처가 다르면 데이터를 차단함으로써 \*\*보안 위협(예: XSS, CSRF 등)\*\*을 방지
* 웹 애플리케이션이 **다른 도메인**에서 실행되는 스크립트가 **중요한 자원**이나 **사용자 데이터**에 접근하지 못하도록 차단

<details>

<summary>SOP 동작과정</summary>

* **브라우저가 페이지 로드**: 브라우저는 클라이언트가 요청한 URL을 로드합니다.
* **스크립트 실행**: 페이지 내에 포함된 자바스크립트는 브라우저 내에서 실행됩니다.
* **외부 자원 요청 시 SOP 검증**: 자바스크립트가 외부 API를 호출하거나, 다른 도메인의 리소스에 접근하려고 할 때 SOP가 발동됩니다.
* **다른 출처면 차단**: 브라우저는 요청의 출처가 현재 페이지와 다른 경우 요청을 차단하고, 이를 통해 보안 위협을 방지합니다.

예를 들어, `http://example.com`에서 실행되는 스크립트는 `http://api.example.com`에 있는 데이터를 기본적으로 접근할 수 없습니다.

</details>

CORS

* 동일 출처 정책을 완화하기 위해 고안된 표준
* **서버 측에서** 특정 도메인에서 오는 요청을 허용할 수 있도록 설정하는 방식
* **응답 헤더**에 `Access-Control-Allow-Origin` 등의 헤더를 추가하여, 어떤 출처에서 요청이 허용되는지를 명시
* **다른 출처**의 웹 애플리케이션도 서버의 리소스에 안전하게 접근

<details>

<summary>CORS 동작과정</summary>

1. 자바스크립트가 `fetch` 또는 AJAX를 사용해 **백엔드 서버**로 데이터를 요청합니다. 이 요청에는 클라이언트 웹 페이지의 **출처(origin)** 정보가 포함

```javascript
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data));
```

이 코드에서 클라이언트는 `https://api.example.com`이라는 백엔드 서버에 데이터를 요청하고 있습니다.

2. 백엔드 서버는 요청의 **`Origin` 헤더**를 확인하고, 자신의 **CORS 설정**에 해당 출처가 허용되어 있는지 확인
3.  **CORS 설정에 포함되지 않은 출처**에서 온 요청이면, 서버는 CORS 관련 오류를 반환하고 요청을 차단합니다.

    **CORS 설정에 포함된 출처**라면, 서버는 응답에 `Access-Control-Allow-Origin` 헤더를 추가하여 요청을 허용합니다.
4. 브라우저는 서버로부터 응답을 받으면, **`Access-Control-Allow-Origin` 헤더**를 확인합니다. 이 헤더에 클라이언트의 출처가 포함되어 있으면, 브라우저는 \*\*SOP(동일 출처 정책)\*\*의 제한을 완화하고 응답을 처리
5. CORS를 통해 서버가 명시적으로 허용한 출처에서만 데이터를 가져오기 때문에, **SOP를 우회**하더라도 **백엔드 서버의 자원**만 불러올 수 있어 보안상 크게 문제가 되지 않습니다.

</details>



## REST가 뭔가요? RESTFUL API는 뭔가요?

<figure><img src="../../.gitbook/assets/image (241).png" alt=""><figcaption></figcaption></figure>

REST

* **Representational State Transfer**의 약자로, **자원**을 이름(URI)으로 구분하고, **HTTP 메서드**를 통해 자원에 대한 **동작**을 정의하는 아키텍처 스타일
* 주요 제약 조건으로는 클라이언트-서버 구조 (Client-Server Architecture), **무상태성 (Statelessness),** 캐시 처리 가능 (Cacheability), 계층화된 시스템 (Layered System), 인터페이스 일관성 (Uniform Interface)
* 클라이언트 서버 구조를 가지며(클라이언트와 서버가 명확히 분리),
* 무상태성이고,&#x20;
* 캐시 처리 가능하며,&#x20;
* 계층화된 시스템(프록시 서버, 로드 밸런서, 게이트웨이 등 중간에 계층을 둘 수 있다) 을 가지고,&#x20;
* 인터페이스 일관성(클<->서는 항상 동일한 방식으로 상호작용. URI, HTTP Method / Status Code)을 만족하는
* 제약조건을 원칙으로 한 아키텍처 스타일입니다.

RESTful API

REST의 원칙과 제약 조건을 준수하여 설계된 API

* URI를 통해 자원의 명확한 식별이 되며,
* HTTP 메서드를 활용하고,
* 무상태성이며,
* 표준 HTTP 상태 코드를 사용하는것을 Restful API라고 합니다.



## URL, URI, URN의 차이점은 뭔가요?

URI - Uniform Resource Identifier. URL과 URN을 포함하는 상위 개념

* 인터넷 상에서 자원을 식별하는 통합된 용어. 어떤 자원이 어디에 있는지 식별할 수 있는 모든 방법
* 마치 하나의 큰 데이터베이스 테이블의 기본키 느낌

URL - Uniform Resource Locator

* 인터넷 상에서 자원의 위치를 나타냅니다.
* 예) http://wonjoonthomaschoi.site

URN - Uniform Resource Name

* 자원의 이름을 나타내며, 자원의 위치와 관계없이 고유하게 식별할 수 있는 이름.
* 예) ISBN(책번호)



## XSS(크로스 사이트 스트립팅) 공격이 무엇인가요?

XSS

* 웹 페이지에서 악의적인 스크립트(주로 자바스크립트)를 삽입하여 **사용자의 브라우저에서 실행**되게 하는 공격
* 주요 목표는 사용자의 **세션 쿠키, 로그인 정보, 개인 데이터**를 탈취하거나, 사용자가 악성 코드를 실행하도록 유도

방어 방법:

* 입력 검증: 사용자가 입력하는 모든 데이터에 대해 유효성 검사를 수행. 스크립트와 관련된 특수 문자가 입력됬는지 확인
* 출력 인코딩: \<script> 같은 태그가 출력될수 있는 경우, 이를 HTML특수 문자로 인코딩하여 스크립트가 실행되지 않게 해야 합니다.
* HTTPOnly쿠키 사용: 쿠키에 HttpOnly 속성을 추가하여 자바스크립트에서 쿠키에 접근할 수 없게 해야합니다.



## CSRF(Cross-Site Request Forgery, 크로스사이트 요청 위조) 공격이 무엇인가요?

CSRF

* 웹 애플리케이션에서 인증된 사용자의 권한을 악용하여, 사용자가 원하지 않는 동작을 서버에 요청하는 것.
* 로그인된 상태라는 것을 악용해, 공격자가 의도하지 않은 요청을 서버로 전송하는 것
* 예) 사용자가 사이트A에 로그인 상태. 사이트 B는 자바스크립트를 이용해 사이트A로 요청을 전송하고, 이떄 세션 쿠키가 사용됨. 인터넷 뱅킹 계좌에서 송금 요청을 보내는 등

방어 방법:

* CSRF 방지 토큰: 각 요청마다 고유하게 생성된 비밀 토큰을 요청에 포함.
* SameSite 쿠키 속성 사용: 외부 사이트에서 전송된 요청과 함께 쿠키를 자동으로 전송하지 않도록 제어
* 서버에서의 Origin 검사



## SQL Injection이 무엇이고 방어하는 방법은 뭔가요?

SQL Injection

* 웹 애플리케이션이 **사용자 입력을 제대로 처리하지 않고** SQL 쿼리에 삽입할 때 발생하는 보안 취약점
* **데이터베이스를 조작**하거나 **비정상적인 SQL 명령**을 실행

방어 방법:

* Prepared Statement 사용: SQL 쿼리를 파라미터화.
* ORM 사용: SQL 쿼리를 직접 작성하지 않게됨.



## 웹 캐시에 대해 설명해주세요.

브라우저 캐시

* 웹 사이트의 리소스를 브라우저 캐시에 저장하여 응답 속도를 높이고 대역폭 절약

CDN 캐시

* 지리적으로 가까운 서버에서 캐시된 자원을 제공하여 로딩 시간 단축

프록시 서버의 캐시

* 프록시 서버는 자주 사용되는 자원을 **중앙 캐시**에 저장하여 여러 클라이언트가 동일한 자원에 접근할 때 빠르게 제공



## 프록시 서버에 대해서 설명해주세요

* **클라이언트와 실제 서버**(목표 서버) 사이에 위치하여 **중개자 역할**을 하는 서버
* 보안 강화, 캐시, 로드 밸런싱, 로깅, 처리율 제한기 등의 역할을 수행
* 포워드 프록시: 클라이언트 앞에 위치. (회사 내부에서 인터넷 사용시 접속 기록 모니터링 등)
* 리버스 프록시: 서버 앞에 위치.



## 리버스 프록시에 대해서 설명해주세요

* **리버스 프록시**는 **클라이언트와 서버 사이에 위치한 프록시 서버**로, 주로 **서버 앞단**에서 클라이언트의 요청을 **대신 받아** 서버로 전달하고, 서버로부터 받은 응답을 클라이언트에게 반환하는 역할
* 보안 강화, 캐시, 로드 밸런싱, 로깅, 처리율 제한기 등의 역할을 수행



## L7 로드 밸런서에 대해 설명해주세요.

* **L7 로드 밸런서**는 **OSI 7계층** 중에서 **애플리케이션 계층(Application Layer)**에서 작동하는 로드 밸런서
* HTTP, HTTPS 같은 **애플리케이션 프로토콜**을 이해하고, **URL**, **쿠키**, **헤더**, **메서드** 등의 정보에 기반해 **더 세밀한 로드 밸런싱**을 수행
* 스티키 세션 기능
* 컨텐츠 기반 라우팅(Http Method 기반)
* 로깅 및 모니터링 가능
* A/B 테스트 및 트래픽 분할도 가능

L4: 패킷의 헤더만 확인\
L7: HTTP 요청의 URI, 헤더, 쿠키, 파라미터 등을 확인



## 커넥션 타임아웃, 리드 타임아웃이 뭔가요?

커넥션 타임아웃:

* 클라이언트가 서버와 연결을 맺는 데 걸리는 시간
* 서버가 응답하지 않거나 네트워크 문제가 발생했을 때, 클라이언트가 **무한정 대기하지 않도록** 보호
* **지정된 시간 안에 실패** 처리

리드 타임아웃:

* 클라이언트가 **서버와 연결된 후, 데이터를 받는 데 걸리는 시간**
* 서버가 데이터 전송을 너무 오래 지연하거나 응답을 하지 않을 때 **대기 시간을 제한**하여 클라이언트가 너무 오랫동안 응답을 기다리지 않도록 합니다.




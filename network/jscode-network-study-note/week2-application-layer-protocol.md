---
description: 애플리케이션 계층 프로토콜
---

# Week2 Application Layer Protocol

## HTTP 프로토콜에 대해 설명해주세요

* 클라이언트와 서버 간의 정보를 주고 받기 위해 사용되는 애플리케이션 계층 프로토콜
* Stateless 프로토콜
* HTTP/1.1: Keep-Alive. 연결을 재사용함
* HTTP/2: 멀티플렉싱을 통한 요청 병렬처리
* HTTP/3: QUIC 프로토콜을 기반으로 더 빠르고 효율적인 데이터 전송

<details>

<summary>HTTP1.1 Keep-Alive</summary>



**Keep-Alive** 헤더가 기본으로 활성화되어, 여러 요청을 **단일 TCP 연결**에서 처리

* 한 번 연결이 맺어지면 이후에도 계속 유지되어 **여러 요청을 재사용할 수 있는 연결**을 지원
* 각 요청마다 **중복된 헤더 정보**(예: 쿠키, 인증 정보)를 계속해서 전송해야 하는 문제가 있었고, 이로 인해 불필요한 대역폭 사용이 발생

</details>

<details>

<summary>HTTP1.1 Pipelining &#x26; Head of line Blocking</summary>

* 여러 요청을 **연속으로 보내는** 기능. 클라이언트는 서버로부터 응답을 기다리지 않고 **여러 요청을 한 번에** 보낼 수 있습니다.
* 하지만 문제는 **TCP 연결에서 요청과 응답이 순차적으로 처리**되기 때문에, **첫 번째 요청의 응답이 완료될 때까지 나머지 요청들이 대기**해야 합니다. 즉, **앞선 요청이 지연되면, 뒤따르는 요청도 모두 지연**되는 현상이 발생하는데, 이것이 **헤드 오브 라인 블로킹(Head-of-Line Blocking)** 문제입니다.

</details>

<details>

<summary>HTTP2. Multiplexing</summary>

**단일 연결**에서 여러 요청과 응답을 **동시에 처리.**&#x20;

* HTTP/1.1에서 발생했던 **헤드 오브 라인 블로킹** 문제를 해결하는 핵심 기능
* 이제 한 연결 내에서 병렬로 여러 요청을 전송. 하나의 요청 지연이 전체 성능에 영향을 미치는 일이 줄어듦.
* **HPACK 헤더 압축**을 사용해 요청과 응답의 헤더 크기를 줄였습니다. (**대규모 트래픽**에서 네트워크 사용량을 크게 줄이는 효과)
* 서버가 클라이언트 요청이 없이도 **필요한 리소스를 먼저 전송**할 수 있는 기능을 제공
* **vs Pipelining: 하나의 연결 내에서 여러 요청과 응답을 병렬로 처리**할 수 있습니다. 즉, **각 요청이 독립적으로** 처리되므로, 하나의 요청이 지연되어도 다른 요청에는 영향을 미치지 않습니다.
*

</details>

<details>

<summary>HTTP3. QUIC (Quick UDP Internet Connections)</summary>

기존의 **TCP** 대신 **UDP** 기반의 **QUIC** 프로토콜을 사용

* **TLS 1.3 암호화**를 전송 계층에 기본 통합. **암호화와 연결 설정이 동시에** 이루어집니다.
* 0-RTT (Zero Round-Trip Time). 최초 연결 설정 시에도 데이터를 즉시 전송
* 개별 스트림을 독립적으로 처리. (TCP는 **패킷 손실**이 발생하면 손실된 패킷이 **재전송될 때까지 전체 스트림이 차단**되는 구조.)&#x20;

</details>

예시:

### 1.1 Keep-alive, Pipelining

서버에 도착순서와 상관없이 처리 순서를 유지.

2, 3, 1 순으로 도착해도 항상 1,2,3 순으로 처리하고 반환.

### 2 Multiplexing

서버에 도착한 순서대로 무조건 서버에서 클라이언트로 받은 순서로 보내야합니다. 먼저 처리 되더라도 먼저 도착한 요청이 처리될때까지 서버에서 응답이 출발하지 않음.

클라이언트에서 요청 1,2,3을 동시에 보내고, 서버에 2, 3, 1 순으로 도착한 상황에서, TCP 특성에 따라 도착한 순서대로 2,3,1 응답을 보내줘야함.

만약 요청 3이 먼저 처리가 완료되더라도 요청2에서 패킷 손실이 나면, 요청2가 처리되기전까지 먼저 처리된 요청3, 요청1은 클라이언트로 보내지않고 기다림



### 3 QUIC

완전 비동기식.

2, 3, 1 순으로 보내도 서버측에서 받는 순서대로 처리(개별 스트림).&#x20;



## HTTP의 요청/응답 모델에 대해 설명해주세요.

요청은 HTTP 메서드로 보내집니다. GET, POST, PUT, DELETE

응답은 상태코드로 응답을 보냅니다. 200 OK, 404 Not Found, 500 Internal Server Error



## HTTP 메서드중 GET과 POST의 차이

GET

* 리소스를 조회할떄 사용
* 멱등합니다. 캐싱 가능
* 리소스를 변경하지 않는 안전한 메서드입니다.

POST

* 새로운 데이터를 전송하거나 생성할때 사용
* 멱등하지 않습니다. 캐싱 불가능
* 리소스 변경으로 안전하지 않습니다.



## HTTP 메서드중 PUT과 PATCH 차이

PUT

* 데이터를 전체적으로 교체할떄 사용
* 멱등. 데이터를 덮어쓰는 경우

PATCH

* 데이터를 일부만 수정할때 사용
* 항상멱등하지 않을 수 있고,  부분적으로 변경.



## HTTP 상태 코드가 뭔가요?

상태 코드는 클라이언트 요청에 대한 서버 결과를 숫자 코드로 표현한 것입니다.  100번대 부터 500번대까지 있습니다.

* 1xx: 정보 응답
* 2xx: 성공
* 3xx: 리다이렉션
* 4xx:  클라이언트 오류
* 5xx: 서버오류

제가 인턴으로 일했던 프로젝트에서는 **550번대**의 **커스텀 상태 코드**를 사용하여 **AI 관련 오류**를 처리한 경험이 있습니다. 예를 들어, AI 모델의 응답 지연이나 내부 처리 오류에 대한 구체적인 상태를 나타내기 위해 **550 AI Processing Error**와 같은 코드를 정의하고 사용했습니다. **550번대** 코드는 **HTTP 표준에는 없지만**, 애플리케이션의 **특수한 비즈니스 로직**을 표현하는 데 유용했습니다.



## HTTP 헤더가 뭔가요?

* **HTTP 헤더**는 **클라이언트와 서버 간의 요청/응답에 대한 추가 정보**를 제공
* 요청(Request)과 응답(Response) 모두에 포함될 수 있으며, **요청 메타데이터, 콘텐츠 형식, 인증 정보, 캐시 설정** 등의 다양한 정보를 포함
* Origin(CORS에서 사용), Content-Type, Authorization, Cache-Control 등이 있습니다.



## HTTP의 무상태성에 대해서 설명해주세요.

* HTTP 프로토콜이 **각 요청을 독립적으로 처리**한다는 것을 의미.&#x20;
* 각각의 요청은 **완전한 정보**를 포함하고 있어야 하며, 요청 사이의 상태를 서버가 유지하지 않는 구조
* 클라이언트를 추적하려면 **쿠키(Cookie)**, **세션(Session)**, **JWT(Json Web Token)** 같은 상태 유지 기술을 사용
* 서버 확장이 용이



## HTTP Keep-alive에 대해 설명해주세요

* HTTP 1.1에 도입된 기능. TCP 연결을 재활용하여 연결 비용을 줄이는 목적.
* **한 번 맺은 TCP 연결을 유지**함으로써, **여러 개의 요청을 하나의 연결에서 처리**



## HTTP 파이프라이닝에 대해 설명해주세요

* **HTTP/1.1**에서 도입된 기능
* **클라이언트가 여러 HTTP 요청을 응답을 기다리지 않고 연속적으로** 보낼 수 있는 방식
* **Head-of-Line Blocking** 문제. 이TCP 연결에서 **요청을 순차적으로 처리**하기 때문에 발생합니다.



## HTTP 상태 코드 중 4xx, 5xx의 차이점에 대해 설명해주세요

4xx

* 클라이언트 측의 오류로 인해 서버가 요청을 처리할 수 없을때
* 클라이언트가 잘못된 요청을 보내거나, 권한이 없는 리소스를 요청하는 경우

5xx

* **서버 측의 문제**로 인해 클라이언트의 요청을 처리하지 못할 때 발생하는 상태 코드
* 서버의 오류나 내부 문제로 인해 요청을 완료할 수 없을 때 주로 발생



##

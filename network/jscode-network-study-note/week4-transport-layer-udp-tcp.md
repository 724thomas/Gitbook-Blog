---
description: UDP, TCP
---

# Week4 Transport Layer - UDP, TCP

## UDP에 대해 설명해주세요

* **비연결형**이면서 **비신뢰성**을 특징으로 하는 전송 계층 프로토콜
* TCP와 달리 **순서 보장**이나 **데이터 손실 복구** 등의 기능이 없습니다.
* **패킷 손실**이 발생
* **연결 설정 없이** 데이터를 바로 전송하기 때문에 속도가 매우 빠릅니다.
* **데이터그램** 기반 전송 방식을 사용하여, 각각의 데이터그램이 독립적으로 전송하며 순서 재조립 로직을 제공하지 않습니다.



## UDP의 장단점을 설명해주세요

장점

* 핸드쉐이크가 필요가 없는 비신뢰성이고 비연결성이라서 데이터를 바로 전송하여 속도가 빠릅니다.
* 순차적으로 처리되지 않아도 큰 문제가 없는 스트리밍같은 곳에 사용됩니다.
* 1:1 / 1:N 통신을 할 수 있어서 멀티캐스트나 브로드캐스트와 같은 대규모 전송에 유용.

단점

* 패킷 손실이 발생할 수 있고, 데이터 손실 복구 등의 기능이 없습니다.
* TCP와 다르게 혼잡제어, 흐름제어가 없습니다.



## UDP의 체크섬에 대해 설명해주세요

* **체크섬**은 데이터 전송 중 발생할 수 있는 **오류를 검출**하기 위한 메커니즘
* UDP에셔 체크섬은 단순히 오류 검출만 수행하고, 오류가 발생하더라도 TCP와는 다르게 이를 수정하거나 재전송하지 않습니다.



## 신뢰적 데이터 전송의 원리 중 전송 후 대기 프로토콜이 뭔가요?

* Stop and Wait Protocol.
* **신뢰적인 데이터 전송을 보장하는 가장 기본적인 프로토콜** 중 하나
* 데이터 전송 -> 수신 확인(Ack) -> 다음 패킷 전송 -> 재전송
* 하나의 패킷만 전송하여 느리지만 신뢰성을 보장.



## 파이프라인 프로토콜이 뭔가요?

* Stop and Wait 프로토콜의 비효율성을 개선하기 위한 방식
* 파이프라이닝은 여러 패킷을 **연속적으로 전송**하면서 동시에 **수신 확인 응답(ACK)**을 기다리는 방식
* 전송 속도 향상.
* Go Back N 방식: 오류 발생시 해당 패킷 이후 모든 패킷을 재전송
* Selective Repeat 방식: 특정 패킷만 재전송

&#x20;**파이프라인 이라는 개념은 여러 단계를 병렬로 처리하여 전체적인 처리 효율을 높이는 방식**



## TCP에 대해 설명해주세요

* **연결 지향형**이면서 **신뢰성을 보장**하는 전송 계층 프로토콜
* 흐름 제어: **수신 측의 처리 능력**을 고려한 전송을 수행
* 혼잡 제어: 송신 측은 네트워크 상황을 감지하여 **혼잡 윈도우(congestion window)**를 조절하며, 데이터 전송 속도를 동적으로 변경 (AIMD +Increase /2 Decrease, Slow Start)



## 3-way handshake에 대해 설명해주세요

* **TCP 프로토콜**에서 **클라이언트와 서버 간의 연결을 설정하는 과정**
* SYN (Synchronize) - 클라이언트 → 서버
* SYN-ACK (Synchronize-Acknowledge) - 서버 → 클라이언트
* ACK (Acknowledge) - 클라이언트 → 서버



## 4-way handshake에 대해 설명해주세요

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

* **4-way handshake**는 **TCP 연결을 종료**할 때 사용하는 절차. 주요 패킷은 **FIN(Finish)**과 **ACK(Acknowledgment)**
* 클라이언트 → 서버: FIN
* 서버 → 클라이언트: ACK
* 서버 → 클라이언트: FIN
* 클라이언트 → 서버: ACK



## TCP 빠른 재전송(Fast Retransmit)에 대해서 설명해주세요

* **패킷 손실**이 발생했을 때, 이를 빠르게 감지하고 **재전송을 신속히 수행**하기 위한 메커니즘
* TCP 재전송 메커니즘은 **타임아웃**을 기다린 후 손실된 패킷을 재전송하는 방식이지만, **빠른 재전송**은 중복된 ACK을 통해 타이머를 기다리지 않고 신속하게 손실된 패킷을 재전송
* 원래는 수신측에서 ACK를 한번만 보냄 -> 계속 보냄
* time out을 기다리지않고, 중복된 ack를 송신측이 받으면 조금 더 빠르게 대처 가능

상황 1:&#x20;

* 송신측: 1,2,3,4,5,6,7,8 을 보낸 상황.
* 수신측: 1,2,3,5,6,7,8 일때, 손실 전, 3에  대한 Ack(4)을 5,6,7 대신 보냄.
* 송신측: 4만 보내게되고, 5,6,7은 받았으므로 처리하지않고, 다음 7에 대한 ACK(8)를 보냄.
* 수신측: 8을 보냄.

상황 2:

* 송신측: 1,2,3,4,5,6,7,8 을 보낸 상황.
* 수신측: 1,2,3,6,7,8 일때, 손실 전, 3에  대한 Ack(4)을 6,7,8 대신 보냄.
* 송신측: 4만 보내게됨.
* 수신측: 4를 받았지만 5도 손실이 발생해서 Ack(5)를 6,7,8 대신 보냄.
* 송신측: 5만 보내게됨.
* 수신측: 6,7,8 은 있으므로 Ack(9)을 보내게됨.



## TCP에서 혼잡제어(Congestion Control)에 대해 설명해주세요

* 네트워크의 **혼잡 상태**를 감지하고, 그에 맞춰 송신 측의 데이터 전송 속도를 조절하는 메커니즘
* **네트워크 과부하**를 방지하고, 패킷 손실과 지연을 줄이기 위해 설계
* Slow Start: 전송이 성공할때마다 혼잡 윈도우를 2배씩 증가.
* Congestion Avoidance(혼잡 회피): 임계값에 도달하면 혼잡 윈도우 증가속도를 선형적으로 변경
* Fast Retransmit(빠른 재전송): 중복된 ACK가 3번 발생하면 타이머를 기다리지않고 재전송
* Fast Recovery(빠른 복구): 패킷 손실후 혼잡 윈도우를 절반으로 줄임.



## TCP에서 흐름제어(Flow Control)에 대해 설명해주세요

* **수신 측의 처리 능력**을 고려하여 송신 측이 보내는 데이터의 양을 조절하는 메커니즘. **수신 측의 버퍼가 넘치지 않도록** 데이터를 제어
* **윈도우 크기(Window Size)**:\
  TCP는 데이터 전송 시 **수신 측의 버퍼 크기에 맞춰 전송량을 조절**합니다. 수신 측은 자신의 **버퍼가 얼마나 남았는지**를 계산하여 **윈도우 크기**로 송신 측에 알립니다. 송신 측은 이 **윈도우 크기만큼** 데이터를 전송할 수 있습니다.
* **슬라이딩 윈도우(Sliding Window)**:\
  TCP는 **슬라이딩 윈도우** 메커니즘을 사용합니다. 수신 측에서 **ACK**을 보낼 때마다 **윈도우 크기**를 업데이트하여, 송신 측이 그에 맞춰 데이터를 보내게 됩니다. 만약 수신 측의 버퍼가 가득 차게 되면, 수신 측은 **윈도우 크기를 0**으로 설정해, 송신 측이 더 이상 데이터를 보내지 않도록 합니다.
* **윈도우 크기 조정**:\
  송신 측이 데이터를 전송하면, 수신 측은 데이터를 **처리하고 ACK**을 보냅니다. 이때 수신 측은 **남은 버퍼 공간**에 맞게 새로운 **윈도우 크기를 설정**하여 송신 측에 전송합니다. 이렇게 하면 송신 측은 **수신 측의 처리 능력에 맞춰** 데이터를 전송할 수 있게 됩니다.

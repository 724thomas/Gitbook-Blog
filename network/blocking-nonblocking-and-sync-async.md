---
description: 블로킹, 논블로킹과 동기, 비동기
---

# Blocking, NonBlocking and Sync, Async

## 블로킹 vs 논블로킹

블로킹과 논블로킹은 <mark style="color:red;">**작업을 수행하는 방식**</mark>에 관한 것입니다.

### 블로킹

* **작업의 진행 방식**: 작업이 완료될 때까지 현재의 작업 흐름이 멈춥니다
* **예시**: 파일을 읽을 때, 읽는 작업이 완료될 때까지 다른 작업을 하지 못합니다.
* **특징**: 작ㅇ버을 기다리는 동안 CPU가 유휴 상태가 될 수 있습니다.

### 논블로킹

* **작업의 진행방식**: 작업이 즉시 반환되며, 작업이 완료되지 않아도 다른 작업을 계속할 수 있습니다.
* **예시**: 파일을 읽으려 할 때, 파일이 준비되지 않았다면 즉시 반환하고 다른 작업을 계속합니다.
* **특징**: 작업이 완료될 때까지 대기하지 않기 떄문에 다른 작업을 효율적으로 수행할 수 있습니다.



## 동기화 vs 비동기화

동기화와 비동기화는 <mark style="color:red;">**코드 실행 흐름**</mark>에 관한 것입니다.

### 동기화

* **코드 실행 방식**: 코드가 순차적으로 실행되며, 하나의 작업이 완료될 때까지 다음 작업이 시작되지 않습니다.
* **예시**: 함수 A를 호출하고, 함수 A가 완료될 때까지 기다린 후 함수 B를 호출합니다.
* **특징**: 코드는 예측 가능한 순서대로 실행됩니다.

### 비동기화

* **코드 실행 방식**: 코드가 동시에 실행될 수 있으며, 작업이 완료되지 않아도 다음 작업을 시작할 수 있습니다.
* **예시**: 함수 A를 호출하고, 함수 A의 완료 여부와 상관없이 함수 B를 호출합니다. 함수 A가 완료되면 콜백이나 프로미스를 통해 결과를 처리합니다.
* **특징**: 코드가 병렬로 실행될 수 있으며, 대기 시간 동안 다른 작업을 수행할 수 있습니다.



요약하자면,

* **블로킹/논블로킹**:
  * **중심**: 특정 작업(주로 I/O)의 완료 여부에 따라 현재 작업 흐름이 멈추는지 여부.
  * **영향**: 작업을 수행하는 동안의 대기 상태.
* **동기화/비동기화**:
  * **중심**: 코드 실행의 흐름과 순서.
  * **영향**: 작업을 완료하기 전과 후의 코드 실행 방식 및 순서.



여기서 조금 헷갈립니다. 그러면 동기화와 블로킹이 비슷한 개념이고, 비동기화와 논블로킹이 비슷한 방식이 아닐까 라는 의문이 듭니다.



## 블로킹 vs 동기화

### **차이점**

* **초점**:
  * 블로킹: 특정 작업이 완료될 때까지 실행 흐름을 멈추는 것.
  * 동기화: 작업의 실행 순서와 관계된 것.
* **대기 방식**:
  * 블로킹: 작업이 완료될 때까지 현재 스레드가 멈춤.
  * 동기화: 작업이 순차적으로 진행되며, 다음 작업이 이전 작업의 완료를 기다림.

## 논블로킹 vs 비동기화

**차이점**

* **초점**:
  * 논블로킹: 작업 호출이 즉시 반환되며, 작업이 완료될 때까지 대기하지 않음.
  * 비동기화: 코드 실행이 병렬로 이루어질 수 있으며, 작업 완료를 기다리지 않고 다른 작업을 시작함.
* **대기 방식**:
  * 논블로킹: 작업이 완료되지 않았을 때도 즉시 반환.
  * 비동기화: 병렬로 작업을 수행하며, 작업 완료 여부에 따라 후속 작업을 처리.





4개의 개념의 조합을 이해하면 동작 방식을 조금 더 상세히 이해할 수 있습니다.

## 동기 블로킹

* **정의**: \
  Sync Blocking 조합은 다른 작업이 진행되는 동안 자신의 작업을 처리하지 않고 (Blocking), 다른 작업의 완료 여부를 바로 받아 순차적으로 처리하는 (Sync) 방식입니다. 다른 작업의 결과가 자신의 작업에 영향을 주는 경우에 활용할 수 있습니다.

<figure><img src="../.gitbook/assets/image (66).png" alt=""><figcaption></figcaption></figure>

* **특징**:
  * 모든 작업이 완료될 때까지 다음 작업을 시작하지 않습니다.
  * 각 작업이 완료될 때까지 현재 스레드가 블로킹됩니다.
  * 가장 직관적인 방식으로, 이해하기 쉽지만 효율성은 낮습니다.
* **사례**: 데이터베이스 쿼리
  * **설명**: 동기 블로킹 방식으로 데이터베이스에 쿼리를 실행하면, 쿼리가 완료될 때까지 프로그램의 흐름이 멈추고 다른 작업을 할 수 없습니다.
  * **예시**: 애플리케이션이 데이터베이스에서 고객 정보를 조회하는 경우, 쿼리가 완료될 때까지 다른 작업을 수행하지 않고 대기합니다.
* 실생활 동작 예시:

```
사장: 출근
직원: 인형 눈알 붙히기 1번 수행
직원: 인형 눈알 붙히기 2번 수행
...
직원: 인형 눈알 붙히기 100번 수행
사장: 퇴근
```

<figure><img src="../.gitbook/assets/image (72).png" alt=""><figcaption></figcaption></figure>

## 동기 논블로킹

* **정의**: Sync Non-Blocking 조합은 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고 (Non Blocking), 다른 작업의 결과를 바로 처리하여 작업을 순차대로 수행 하는 (Sync) 방식입니다.

<figure><img src="../.gitbook/assets/image (69).png" alt=""><figcaption></figcaption></figure>

* **특징**:
  * 각 작업이 바로 완료되지 않으면 즉시 반환되고, 다른 작업을 시도할 수 있습니다.
  * 반복적으로 작업의 완료 여부를 확인(폴링)합니다.
* **사례**: 서버 상태 점검
  * **설명**: 서버의 상태를 주기적으로 점검하는 프로그램이 동기 논블로킹 방식으로 작동할 수 있습니다. 각 점검 작업은 바로 완료되지 않으면 즉시 반환하고, 다른 점검 작업을 시도합니다.
  * **예시**: 여러 서버의 상태를 점검하는 프로그램이, 각 서버에 대한 상태 요청을 보내고, 즉시 응답이 오지 않으면 다음 서버로 넘어가며 주기적으로 상태를 재점검합니다.
* 실생활 동작 예시:

```
사장: 출근
직원: 인형 깔알 붙히기 1번 수행
사장: 유튜브 시청...
직원: 인형 눈알 붙히기 2번 수행
사장: 유튜브 시청...
...
직원: 인형 눈알 붙히기 100번 수행
사장: 유튜브 시청...
사장: 퇴근
```

<figure><img src="../.gitbook/assets/image (73).png" alt=""><figcaption></figcaption></figure>



또 다른 예시는 게임입니다. 맵을 이동할때 생각을 해보면, 우선 맵을 다운로드 해야합니다. 그동안에는 로딩 화면이 뜨고, 이 로딩 화면은 로딩바가 채워지는 프로그램이 수행하고 있는 것입니다. 즉 제어권은 여전히 갖고 있어 화면에 로딩%가 표시되는 것입니다. 그리고 끊임없이 맵 데이터가 어느정도 로드가 됬는지 조회합니다. <mark style="color:red;">**자신의 작업을 계속하고 있지만, 다른 작업과의 동기를 위해 계속해서 다른 작업이 끝났는지 조회하는 것입니다.**</mark>

<figure><img src="../.gitbook/assets/image (71).png" alt=""><figcaption></figcaption></figure>

## 비동기 블로킹

* **정의**: Async Blocking 조합은 다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다리는 (Blocking), 다른 작업의 결과를 바로 처리하지 않아 순서대로 작업을 수행하지 않는 (Async) 방식입니다. Async-blocking 의 경우는 <mark style="color:red;">**실무에서 잘 마주하기 쉽지 않아 다룰일이 거의 없습니다.**</mark>
* 비동기 블로킹이 나오게된 배경:
  * 동기 & 블로킹 I/O의 경우 직관적이나, 여러 개의 I/O를 동시에 처리할 수 없다.
  * 논블로킹 I/O는 프로세스들의 작업을 컨트롤하는 것이 까다롭다.
  * 그렇다고 동기 & 블로킹 I/O와 멀티 프로세싱이나 쓰레딩을 결합해서 쓰자니 자원 문제도 있고 프로세스/스레드 간 통신이나 동기화가 어렵다.

<figure><img src="../.gitbook/assets/image (70).png" alt=""><figcaption></figcaption></figure>

* **특징**:
  * 여러 작업이 동시에 시작될 수 있지만, 각 작업은 여전히 블로킹됩니다.
  * 주로 비동기 호출에서 블로킹 함수를 사용할 때 발생합니다.
* **사례**: 웹 서버에서 블로킹 I/O 호출
  * **설명**: 비동기 웹 서버에서 데이터베이스 쿼리와 같은 블로킹 I/O 작업을 실행하는 경우, 이 작업이 완료될 때까지 해당 요청을 처리하는 스레드가 대기하게 됩니다.
  * **예시**: 비동기 웹 서버가 클라이언트 요청을 처리하는 동안, 데이터베이스에서 데이터를 가져오기 위해 블로킹 쿼리를 실행하여 해당 요청이 처리되기까지 대기 상태에 놓입니다.

## 비동기 논블로킹

*   **정의**: Async Non Blocking 조합은 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고 (Non Blocking), 다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 (Async) 방식입니다. 다른 작업의 결과가 자신의 작업에 영향을 주지 않은 경우에 활용할 수 있습니다.



<figure><img src="../.gitbook/assets/image (68).png" alt=""><figcaption></figcaption></figure>

* **특징**:
  * 가장 효율적인 방식으로, 작업이 완료될 때까지 대기하지 않고 다른 작업을 계속 수행합니다.
  * 작업 완료 시점에 콜백을 사용하거나, 프로미스 또는 `async/await`을 사용하여 결과를 처리합니다.
*   **사례**: 실시간 채팅 애플리케이션

    * **설명**: 실시간 채팅 애플리케이션은 네트워크 I/O를 비동기 논블로킹 방식으로 처리하여, 메시지를 보내고 받는 동안 대기하지 않고 다른 작업(예: UI 업데이트, 알림 처리)을 수행할 수 있습니다.
    * **예시**: 채팅 애플리케이션에서 메시지를 전송할 때, 메시지가 서버에 도착할 때까지 대기하지 않고, 사용자는 다른 메시지를 작성하거나 이전 메시지를 확인할 수 있습니다.
    * 실생활 동작 예시:

    ```
    사장: 출근
    사장: 퇴근
    직원: 인형 눈알 붙히기 1번 수행
    직원: 인형 눈알 붙히기 2번 수행
    ...
    직원: 인형 눈알 붙히기 100번 수행
    직원: 눈알 결산 보고
    ```

<figure><img src="../.gitbook/assets/image (74).png" alt=""><figcaption></figcaption></figure>





## 요약

* **동기 블로킹**: 작업이 순차적으로 실행되고, 각 작업이 완료될 때까지 현재 스레드가 대기.
* **동기 논블로킹**: 작업이 순차적으로 실행되지만, 각 작업이 완료될 때까지 대기하지 않고 다른 작업을 시도 하면서 작업완료를 확인.
* **비동기 블로킹**: 작업이 동시에 시작될 수 있지만, 각 작업은 블로킹되어 완료될 때까지 대기.
* **비동기 논블로킹**: 작업이 동시에 실행될 수 있으며, 작업이 완료되지 않아도 다른 작업을 계속 수행.

# TCP vs UDP

## TCP (Transmission Control Protocol)

### 특징

* 연결 지향: 데이터 전송을 시작하기 전에 송신자와 수신자 간에 연결을 설정합니다. (3way handshake)
* 신뢰성: TCP는 데이터가 정확하고 순서대로 전달되도록 보장합니다. 손실될 패킷은 재전송되고, 중복된 패킷은 삭제되고, 순서가 어긋난 패킷은 재정렬됩니다.
* 흐름제어: TCP는 송신자가 수신자의 처리 능력을 초과하지 않도록 데이터를 조절하는 흐름 제어를 수행합니다.
* 오류 검출 및 수정: 전송된 데이터에 대한 체크섬을 포함하고, 오류가 발견되면 데이터를 재전송합니다.
* 속도: 위 특징들로 인해 상대적으로 UDP보다 느립니다.



### 헤더

<figure><img src="../../.gitbook/assets/image (184).png" alt=""><figcaption></figcaption></figure>

* Source Port(16): <mark style="color:red;">**데이터가 송신되는 포트 번호**</mark>로, 송신자의 애플리케이션을 식별합니다
* Destination Port(16): <mark style="color:red;">**데이터가 수신되는 포트 번호**</mark>로, 수신자의 애플리케이션을 식별합니다
* Sequence Number(32): <mark style="color:red;">**전송된 데이터의 순서를 나타내는 번호**</mark>이고, 데이터의 순서를 보장하고 재전송을 관리합니다.
* Acknowledgement Number(32): <mark style="color:red;">**수신자가 다음으로 기대하는 시퀀스 번호**</mark>이고, 데이터 수신을 확인하고 송신자에게 알립니다.
* Header Length(4): <mark style="color:red;">**TCP 헤더의 길이를 나타내고, 데이터가 시작되는 위치**</mark>를 지정합니다.
* Reserved(6): 현재는 사용되지 않지만, 미래에 사용되기 위한 필드
* Code Bits(6): <mark style="color:red;">**제어 플래그(URG, ACK, PSH, RST, SYN, FIN)**</mark>. 연결 설정, 데이터 전송 제어, 연결 종료 등을 관리.
  * ACK: 수신자가 마지막으로 받은 데이터의 시퀀스 번호.
  * SYN: 동기화 플래그로, 연결 설정을 위해 사용됩니다.
  * FIN: 더 이상 전송할 데이터가 없음을 나타냅니다. 해당 패킷을 수신하면,  TCP 연결 종료 절차가 시작됩니다.

```yaml
---ACK---

A -> B 데이터 전송
Source Port: 12345
Destination Port: 80
Sequence Number: 1001
ACK: 0 (ACK 플래그 비설정)
Data: "Hello, B!"

B -> A 확인 응답
Source Port: 80
Destination Port: 12345
Sequence Number: 2001 (B의 새로운 시퀀스 번호)
ACK: 1 (ACK 플래그 설정)
Acknowledgment Number: 1002 (다음으로 기대하는 시퀀스 번호)
Data: 없음

A는 ACK 플래그가 설정된 패킷을 수신하고, 응답번호 1002를 확인하여 
1001까지 데이터를 받았다는 것을 알게됩니다. A는 시퀀스번호 1002부터 전송 준비합니다.
```

```yaml
---SYN---

A -> B 연결요청
Source Port: 12345
Destination Port: 80
Sequence Number: 1000 (클라이언트 A의 초기 시퀀스 번호)
SYN: 1 (SYN 플래그 설정)
ACK: 0 (ACK 플래그 비설정)
Data: 없음
클라이언트 A가 서버 B에게 연결 요청을 보냅니다. 이 패킷은 
SYN 플래그가 설정되어 있으며, 초기 시퀀스 번호를 포함합니다.

B -> A 확인응답
Source Port: 80
Destination Port: 12345
Sequence Number: 2000 (서버 B의 초기 시퀀스 번호)
SYN: 1 (SYN 플래그 설정)
ACK: 1 (ACK 플래그 설정)
Acknowledgment Number: 1001 (클라이언트 A의 다음 시퀀스 번호)
Data: 없음
서버 B가 클라이언트 A의 요청을 확인하고 응답합니다. 이 패킷은 
SYN과 ACK 플래그가 모두 설정되어 있으며, 서버 B의 초기 시퀀스 
번호와 클라이언트 A의 시퀀스 번호에 대한 확인 응답 번호를 포함합니다.

A -> B 확인응답
Source Port: 12345
Destination Port: 80
Sequence Number: 1001 (클라이언트 A의 새로운 시퀀스 번호)
SYN: 0 (SYN 플래그 비설정)
ACK: 1 (ACK 플래그 설정)
Acknowledgment Number: 2001 (서버 B의 다음 시퀀스 번호)
Data: 없음
클라이언트 A가 서버 B의 응답을 확인하고, 연결을 확립합니다. 
이 패킷은 ACK 플래그가 설정되어 있으며, 서버 B의 시퀀스 
번호에 대한 확인 응답 번호를 포함합니다.
```

* Wondow(16): 수신자가 수신할 수 있는 데이터의 양으로, 흐름제어를 통해 송신 속도를 조절합니다.
* Checksum(16): 헤더와 데이터의 오류 검출을 위한 체크섬이고 데이터 무결성을 확인합니다.
* Urgent Pointer(16): 긴급 데이터의 끝을 가리키는 포인터로, 긴급 데이터를 신속하게 처리하기 위한 용도
* Options(0 or 32, if any): TCP 확장 기능으로, 선택적으로 추가 기능 제공
* Data(Varies): 전송되는 실제 데이터.

### 헤더 예시

```yaml
  Source Port: 12345
  Destination Port: 80
  Sequence Number: 1001
  Acknowledgment Number: 2002
  Header Length: 5 (20 bytes)
  Reserved: 0
  Code Bits: 000010 (ACK)
  Window: 8192
  Checksum: 0x1C2B
  Urgent Pointer: 0
  Options: None
  Data: "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n"
```



### 순서 보장 메커니즘

* **시퀀스 번호 (Sequence Number)**
  * **설명:** 각 TCP 세그먼트는 시퀀스 번호를 가지고 있습니다. 이 번호는 세그먼트의 데이터가 원본 데이터 스트림에서 차지하는 바이트의 위치를 나타냅니다.
  * **작동 원리:** 송신자는 첫 번째 바이트에 시퀀스 번호를 부여하고, 이후 전송되는 바이트마다 시퀀스 번호를 증가시킵니다.
* **확인 응답 번호 (Acknowledgment Number)**
  * **설명:** 수신자는 받은 데이터에 대해 확인 응답(ACK)을 보내고, 다음에 기대하는 시퀀스 번호를 포함합니다.
  * **작동 원리:** 송신자는 수신자로부터 ACK를 받아 이전에 전송한 데이터가 성공적으로 도착했음을 확인합니다. 수신자는 누락된 데이터가 있을 경우 해당 부분을 요청하거나 기다립니다.
* **재전송 메커니즘**
  * **설명:** 송신자는 일정 시간 내에 ACK를 받지 못하면 데이터를 재전송합니다.
  * **작동 원리:** 타임아웃이 발생하면 송신자는 해당 시퀀스 번호의 데이터를 다시 전송합니다.
* **버퍼링 및 재정렬**
  * **설명:** 수신자는 수신된 데이터를 버퍼에 저장하고, 시퀀스 번호를 기반으로 올바른 순서로 재정렬합니다.
  * **작동 원리:** 수신자가 중간에 누락된 데이터나 순서가 뒤바뀐 데이터를 받으면, 이를 버퍼에 저장하여 올바른 순서로 재조립합니다.

### 순서 보장 메커니즘 예시

#### 작동 예시

1.  **데이터 전송 시작**

    * 클라이언트가 서버에게 데이터를 전송하기 시작합니다. 첫 번째 데이터 세그먼트는 시퀀스 번호 1000을 가집니다.

    ```less
    클라이언트 -> 서버: [Seq=1000, Data="Hello"]
    ```
2.  **수신자가 확인 응답을 보냄**

    * 서버는 데이터를 수신하고, 다음에 기대하는 시퀀스 번호 1005(예: "Hello"가 5바이트이므로)에 대한 ACK를 보냅니다.

    ```less
    서버 -> 클라이언트: [Ack=1005]
    ```
3.  **연속된 데이터 전송**

    * 클라이언트는 다음 데이터 세그먼트를 시퀀스 번호 1005로 전송합니다.

    ```less
    클라이언트 -> 서버: [Seq=1005, Data="World"]
    ```
4.  **데이터의 일부분이 손실됨**

    * 네트워크 문제로 인해 시퀀스 번호 1005의 세그먼트가 손실되었습니다. 서버는 이후 데이터인 시퀀스 번호 1010(예: "World"가 5바이트이므로) 세그먼트를 받게 됩니다.

    ```less
    클라이언트 -> 서버: [Seq=1010, Data="!"]
    ```
5.  **수신자가 누락된 데이터 요청**

    * 서버는 시퀀스 번호 1005의 데이터가 누락되었음을 감지하고, 그에 대한 ACK를 다시 요청합니다.

    ```less
    서버 -> 클라이언트: [Ack=1005]
    ```
6.  **송신자가 누락된 데이터 재전송**

    * 클라이언트는 시퀀스 번호 1005의 데이터를 재전송합니다.

    ```less
    클라이언트 -> 서버: [Seq=1005, Data="World"]
    ```
7.  **수신자가 데이터 재정렬**

    * 서버는 누락된 데이터를 수신하고, 이를 올바른 순서로 재정렬합니다. 이제 서버는 "Hello World!" 메시지를 완전하게 수신합니다.

    ```less
    서버 -> 클라이언트: [Ack=1015]
    ```



### 흐름 제어

수신자가 수신할 수 있는 데이터의 양을 조절하여 송신자가 이를 초과하지 않도록 합니다. 이를 위해 TCP는 Window필드를 사용합니다. 수신자가 윈도우 크기를 설정하여 송신자에게 알려주면, 송신자는 해당 윈도우 크기 내에서만 데이터를 전송합니다.

### 흐름 제어 예시

클라이언트A가 서버B에게 대량의 데이터를 전송하려고 준비합니다.  서버B의 수신 버퍼는 한정되어 있으므로, 클라이언트A가 서버B의 수신 버퍼를 초과하지 않게끔 흐름 제어가 필요합니다.

1.  초기 상태

    클라이언트A와 서버B 간에 TCP 연결을 합니다.

    서버B의 초기 수신 윈도우 크기는 5,000입니다.
2. 클라이언트A가 서버B에게 데이터 전송 시작\
   클라이언트A는 서버B의 수신 윈도우 크기(5,000)을 확인한 후, 4,000 바이트의 데이터를 전송합니다.\
   <mark style="color:red;">**클라이언트 -> 서버: \[시퀀스 번호 = 1000, 데이터 = 4000 바이트]**</mark>
3. **서버B가 데이터 수신 및 확인 응답 전송**\
   서버(B)는 데이터를 수신하고, 이를 처리한 후 수신 윈도우 크기를 1000 바이트로 줄여 클라이언트(A)에게 알립니다.\
   <mark style="color:blue;">**서버 -> 클라이언트: \[ACK, 확인 응답 번호 = 5000, 수신 윈도우 크기 = 1000 바이트]**</mark>
4. 클라이언트A가 추가 데이터 전송\
   클라이언트A는 서버B의 수신 윈도우 크기를 확인하고, 1,000 바이트의 데이터를 추가로 전송합니다.\
   <mark style="color:red;">**클라이언트 -> 서버: \[시퀀스 번호 = 5000, 데이터 = 1000 바이트]**</mark>
5. 서버 B가 데이터 수신 및 확인 응답 전송\
   서버(B)는 데이터를 수신하고, 수신 버퍼를 비우면서 수신 윈도우 크기를 5000 바이트로 다시 늘립니다.\
   <mark style="color:blue;">**서버 -> 클라이언트: \[ACK, 확인 응답 번호 = 6000, 수신 윈도우 크기 = 5000 바이트]**</mark>



### 혼잡 제어

혼잡 제어는 네트워크의 혼잡을 방지하고 처리하기 위해 다양한 알고리즘을 사용합니다. 혼잡 제어 알고리즘에는 느린시작 Slow Start, 혼잡회피 Congestion Avoidance, 빠른 재전송Fast Retransmit, 빠른 복구Fast Recovery, AIMD, TCP Tahoe가 있습니다.

* Slow Start (느린 시작)
  * 처음에는 혼잡 윈도우(cwnd)를 1 MSS(Maximum Segment Size)로 설정합니다.
  * 매 전송 라운드마다 윈도우 크기가 두 배로 증가합니다. 즉, 성공적으로 수신 확인 응답(ACK)을 받을 때마다 윈도우 크기가 지수적으로 증가합니다. (1, 2, 4, 8, ...)
  * cwnd가 ssthresh(slow start threshold) 값에 도달할 때까지 증가를 계속합니다.
  * cwnd가 ssthresh를 초과하면 Congestion Avoidance(혼잡 회피) 단계로 전환됩니다.
* Congestion Avoidance (혼잡 회피)\
  혼잡 회피 단계에서는 혼잡 윈도우(cwnd)를 선형적으로 증가시킵니다. 네트워크의 혼잡을 감지하고 이를 방지하기 위해 더 신중하게 증가합니다.
  * cwnd가 ssthresh에 도달한 후부터 혼잡 회피 단계로 진입합니다.(ssthresh = 임계점까지만 slow start를 사용하겠다는 의미)
  * 각 전송 라운드마다 cwnd를 선형적으로 1 MSS씩 증가시킵니다.
* Fast Retransmit   (빠른 재전송)\
  중복된 ACK 패킷을 통해 손실된 패킷을 빠르게 감지하고 재전송합니다. 타임아웃을 기다리지 않고 손실된 패킷을 빨리 복구합니다.
  * 송신자가 동일한 패킷에 대해 세 개의 중복된 ACK를 수신하면 손실된 패킷으로 간주합니다.
  * 타임아웃을 기다리지 않고 즉시 해당 패킷을 재전송합니다.
* Fast Recovery (빠른 복구)\
  혼잡 회피 단계에서 혼잡이 발생했을때, 혼잡 윈도우(cwnd)를 조정하는 방법입니다. 혼잡 윈도우를 절반으로 줄인 후 선형적으로 증가시킵니다.
  * 세 개의 중복된 ACK를 수신하면 ssthresh를 현재 cwnd의 절반으로 설정합니다.&#x20;
  * cwnd를 ssthresh로 설정하고 Fast Recovery 모드로 진입합니다.
  * Fast Recovery 모드에서는 새로운 ACK를 수신할 때마다 cwnd를 1 MSS씩 증가시킵니다.
  * 손실된 패킷의 ACK를 수신하면 Fast Recovery 모드에서 빠져나와 Congestion Avoidance 단계로 돌아갑니다.
* Additive Increase Multiplicative Decrease (AIMD)\
  TCP 혼잡 제어의 기본 원칙으로, 혼잡 윈도우를 선형적으로 증가시키고 혼잡이 감지되면 지수적으로 감소시키는 메커니즘.

<figure><img src="../../.gitbook/assets/image (186).png" alt=""><figcaption></figcaption></figure>

* **TCP Tahoe**&#x20;
  * 느린 시작 (Slow Start)
  * 혼잡 회피 (Congestion Avoidance)
  * 빠른 재전송 (Fast Retransmit)
  * 타임아웃이나 중복된 ACK를 수신하면 혼잡 윈도우(cwnd)를 1로 설정하고, ssthresh를 현재 cwnd의 절반으로 설정.

<figure><img src="../../.gitbook/assets/image (187).png" alt=""><figcaption></figcaption></figure>

* **TCP Reno:** TCP Tahoe의 개선 버전으로, 빠른 복구(Fast Recovery) 메커니즘을 추가하여 성능을 향상시켰습니다.
  * 느린 시작 (Slow Start)
  * 혼잡 회피 (Congestion Avoidance)
  * 빠른 재전송 (Fast Retransmit)
  * 빠른 복구 (Fast Recovery)
  * 중복된 ACK를 수신하면 빠른 재전송을 수행하고, 혼잡 윈도우를 절반으로 줄인 후 빠른 복구를 통해 혼잡 윈도우를 선형적으로 증가시킴.

<figure><img src="../../.gitbook/assets/image (188).png" alt=""><figcaption></figcaption></figure>

* **TCP New Reno:** 빠른 복구 메커니즘을 더 효율적으로 개선한 알고리즘으로, 실전에서 많이 사용됩니다.
* **TCP Cubic:** 높은 대역폭-지연 제품 네트워크(BDP 네트워크)에서 성능을 최적화하기 위해 설계된 알고리즘.
* **TCP BBR:** 패킷 손실 대신 대역폭과 지연 시간에 기반한 최신 혼잡 제어 알고리즘.

## UDP

### 특징

* 비연결 지향: 송신자는 수신자의 상태나 데이터 수신 여부를 확인하지 않습니다.
* 비신뢰성: UDP는 데이터 전송의 신뢰성을 보장하지 않습니다. 패킷이 손실되거나 순서가 뒤바뀌는 경우, 이에 대한 보상을 하지 않습니다.
* 흐름 제어 없음: 흐름 제어를 제공하지 않아서, 송신자가 수신자의 처리 능력을 초과할 수 있습니다.
* 오류 검출: 전송된 데이터에 대한 체크섬을 포함하지만, 오류를 수정하지 않습니다. 오류가 발견되면 해당 데이터는 단순히 폐기됩니다.
* 속도: TCP보다 빠릅니다.


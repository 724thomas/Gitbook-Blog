# Equals() & ==

**보완할 점**

* `equals()`가 hash값을 비교한다는 부분은 오해의 소지가 있어. `equals()`는 실제 문자열 내용을 `char[]` 배열 단위로 비교하고, 해시와는 관련 없어.
* 스트링 풀이 `equals()` 비교에 영향을 준다고 생각한 점은 오해야. 스트링 풀은 `==`에만 관련 있어.
* `equals()`를 오버라이딩할 때 `hashCode()`도 함께 오버라이딩해야 한다는 점을 놓쳤어.





## Java에서 `==` 연산자와 `equals()` 메서드의 차이점은 무엇인가요?

* `==`: 두 참조 변수가 **동일한 객체를 참조하고 있는지(주소값)** 비교.
* `equals()`: 두 객체가 **논리적으로 같은 값인지** 비교. (`Object`의 기본 구현은 `==`과 같지만, `String`, `Integer` 등은 `equals()`를 오버라이딩하여 **내용을 비교**함)



## 그럼 `String` 클래스에서 `equals()`는 어떻게 동작하나요? 내부적으로 어떤 방식으로 문자열을 비교하나요?

* `equals()`는 **문자열의 길이**를 먼저 확인하고, 길이가 같다면 **char 배열을 인덱스로 하나씩 비교**하여 결과를 반환.
* 스트링 풀 여부는 `==`에만 영향을 미침



## 그렇다면 `new String("abc")`로 두 개의 문자열을 만들고 `equals()`로 비교하면 어떤 결과가 나오고, 왜 그런 결과가 나오는지 설명해 줄 수 있을까?

* `new String("abc")`는 서로 다른 객체를 생성하지만 내부 문자열은 동일.
* `equals()`는 내부 문자열 비교이므로 결과는 `true`.



## String 클래스에서 `equals()`가 내부적으로 문자열을 하나씩 비교한다고 했는데, 구체적으로 어떤 메서드를 이용해서 비교하고, 그 비교는 어떤 방식(예: 어떤 루프나 조건문)으로 이루어지는지 알고 있어?

* 동등성 확인 (`==`)
* 타입 검사 (`instanceof`)
* 길이 비교
* char\[] 배열 비교



## 만약 두 문자열의 길이가 다르면 바로 false를 반환한다고 했는데, 왜 이런 순서를 먼저 두는 게 효율적인지 설명해 줄 수 있어?

* 길이 비교는 O(1) 연산으로, 두 문자열이 다르다는 걸 **빠르게 판단할 수 있는 조건**.
* 길이가 다르면 내용이 같을 수 없으므로 바로 `false`를 반환하는 게 성능상 유리함.



## 자바에서 `equals()`를 오버라이딩하는 클래스(예: 사용자 정의 클래스)를 만들 때, 어떤 점들을 주의해서 구현해야 할까? equals 관련된 다른 메서드와도 관련지어서 설명해줘.

* `equals()` 오버라이딩 시 다음을 지켜야 함:
  * **reflexive**: 자기 자신과는 항상 같아야 함
  * **symmetric**: A.equals(B) == B.equals(A)
  * **transitive**: A=B, B=C → A=C
  * **consistent**: 값이 바뀌지 않는 한 항상 같은 결과
  * **null 비교 시 false 반환**
* **`hashCode()`도 반드시 함께 오버라이딩**해야 함. `equals()`로 논리적으로 같다고 판단되는 객체는 동일한 `hashCode()`를 가져야 `HashMap`, `HashSet`에서 문제 없음.

---
description: 예외 처리
---

# 16. Exception Handling

### 치트시트

* `try/catch/finally`: 문법은 자바와 동일, 표현식으로 사용 가능
* Checked Exception 없음 → throws 불필요
* 사용자 정의 예외는 자바와 동일
* 함수형 스타일: `runCatching`, `Result<T>`
* 서버 활용: Repository 오류, API 응답 래핑, 트랜잭션 안전 처리

***

### 1) 기본 문법

* `try`/`catch`/`finally`는 자바와 동일
* `try`는 **표현식(Expression)** → 값을 반환 가능

```kotlin
val result: Int = try {
    riskyOperation()
} catch (e: IOException) {
    -1
} finally {
    println("done")
}
```

👉 자바와 달리 `try` 자체를 변수에 할당 가능.

***

### 2) Checked Exception 없음

* 자바: `IOException`, `SQLException` 등은 반드시 `throws` 선언 필요
* 코틀린: **모든 예외는 unchecked**
  * `throws` 키워드 없음
  * 호출하는 쪽에서 반드시 try-catch 할 필요 없음

```kotlin
fun readFile(path: String): String {
    throw IOException("fail") // throws 안 붙여도 됨
}
```

👉 서버 개발 시 장점: 불필요한 보일러플레이트 제거\
👉 단점: 예외 처리를 강제하지 않으므로 팀 규약이 필요

***

### 3) 예외 객체

* 모든 예외는 `Throwable`을 상속
* 사용자 정의 예외도 자바와 동일하게 생성 가능

```kotlin
class BusinessException(msg: String): RuntimeException(msg)
```

***

### 4) 함수형 스타일 예외 처리

#### runCatching

```kotlin
val result = runCatching { riskyOperation() }

result.onSuccess { println("ok: $it") }
      .onFailure { println("error: ${it.message}") }
```

* try-catch 대체 가능
* **Result\<T>** 객체로 감싸 반환PPT

#### fold / getOrElse

```kotlin
val value = runCatching { riskyOperation() }
    .getOrElse { -1 }
```

***

### 5) 서버 개발 활용 패턴

#### A. Repository 에러 처리

```kotlin
fun findUser(id: Long): Result<User> =
    runCatching { repo.find(id) ?: throw NotFoundException() }
```

#### B. API 응답 Wrapping

```kotlin
fun <T> handle(block: () -> T): ApiResponse<T> =
    runCatching { block() }
        .fold(
            onSuccess = { ApiResponse.success(it) },
            onFailure = { ApiResponse.error(it.message ?: "Unknown") }
        )
```

#### C. 트랜잭션 처리

```kotlin
@Transactional
fun saveUser(user: User): Result<User> =
    runCatching { repo.save(user) }
```

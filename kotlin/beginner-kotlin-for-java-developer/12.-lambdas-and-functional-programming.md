---
description: 람다와 함수형 프로그래밍
---

# 12. Lambdas & Functional Programming

### 치트시트

* 함수 타입: `(A,B) -> R`
* 람다 변수: `val f = { x: Int -> x * 2 }`
* `it`: 단일 인자 생략 가능
* 트레일링 람다: `list.forEach { println(it) }`
* 클로저: 외부 변수 자유롭게 캡처
* 고차 함수: 파라미터/반환값으로 함수 사용
* 서버 활용: DTO 변환, 로깅/측정 유틸, 라우팅 DSL

***

### 1) Java vs Kotlin 함수 취급 차이

* **Java**: JDK 8부터 람다와 스트림 API 도입, 하지만 함수는 여전히 2급 시민 (익명 클래스 대체 수준)
* **Kotlin**: 함수 자체가 값 → 변수에 저장, 인자로 전달, 반환 가능

```kotlin
val sum: (Int, Int) -> Int = { a, b -> a + b }
println(sum(3, 4)) // 7
```

***

### 2) 람다 기본 문법

* 함수 타입 표기: `(파라미터 타입...) -> 반환 타입`
* 마지막 파라미터가 함수라면, 소괄호 밖에 람다 배치 가능 (트레일링 람다)

```kotlin
val square: (Int) -> Int = { it * it }
listOf(1,2,3).forEach { println(it) }
```

* 여러 줄 람다 → 마지막 표현식이 반환값

```kotlin
val max = { a: Int, b: Int ->
    if (a > b) a else b
}
```

***

### 3) Closure (클로저)

* 자바: 람다에서 사용할 변수는 final 또는 effectively final만 가능
* 코틀린: **외부 변수를 자유롭게 캡처** 가능

```kotlin
var count = 0
val inc = { count++ }
inc()
println(count) // 1
```

👉 이 “변수 포획”을 가능케 하는 구조를 \*\*클로저(Closure)\*\*라 부름

***

### 4) 고차 함수 (Higher-order functions)

* 함수를 파라미터/반환값으로 받는 함수
* 코틀린 표준 라이브러리의 핵심 (filter, map, reduce 등)

```kotlin
fun operate(x: Int, y: Int, op: (Int, Int) -> Int): Int =
    op(x, y)

val sum = operate(3, 4) { a, b -> a + b }
```

***

### 5) 서버 개발 활용 패턴

#### A. 컬렉션 가공

```kotlin
val activeUsers = users.filter { it.active }.map { it.email }
```

→ 자바 스트림보다 간결하고 null-safe.

#### B. 공통 로직 추상화

```kotlin
fun <T> measureTime(block: () -> T): T {
    val start = System.currentTimeMillis()
    return block().also { println("Took ${System.currentTimeMillis()-start}ms") }
}

measureTime { heavyQuery() }
```

→ 공통 부가기능(로깅, 성능 측정)을 고차 함수로 추상화.

#### C. DSL 설계

```kotlin
fun route(path: String, handler: (Request) -> Response) { ... }

route("/health") { req -> Response(200, "OK") }
```

→ Ktor 같은 서버 프레임워크에서 DSL 기반 라우팅 지원.
